<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>COH - Drought & Public Sewer Overflow</title>
  <!-- Chart.js + date adapter + zoom plugin via CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@latest"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2"></script>
  <!-- ArcGIS JS API -->
  <link rel="stylesheet" href="https://js.arcgis.com/4.29/esri/themes/dark/main.css">
  <script src="https://js.arcgis.com/4.29/"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: linear-gradient(145deg, #0d0d1a, #1a1a33);
      color: #e0e0e0;
      font-family: 'Orbitron', 'Segoe UI', sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      overflow-x: hidden;
      background-image: radial-gradient(circle at 50% 50%, rgba(0, 212, 255, 0.1) 0%, transparent 70%);
    }
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

    .container {
      display: flex;
      flex-direction: column;
      width: 100%;
      min-height: 100vh;
      background: rgba(20, 20, 40, 0.8);
      box-shadow: inset 0 0 20px rgba(0, 212, 255, 0.1);
    }
    .sidebar {
      width: 100%;
      padding: 0.8rem;
      background: linear-gradient(180deg, rgba(20, 20, 40, 0.95), rgba(10, 10, 30, 0.95));
      border-bottom: 1px solid rgba(0, 212, 255, 0.4);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(10px);
    }
    .sidebar summary {
      cursor: pointer;
      font-size: 1.1rem;
      color: #00d4ff;
      text-shadow: 0 0 8px #00d4ff;
      padding: 0.5rem 0;
      border-bottom: 1px solid rgba(0, 212, 255, 0.3);
      margin-bottom: 0.5rem;
      transition: all 0.2s ease;
    }
    .sidebar summary:hover {
      text-shadow: 0 0 12px #00d4ff;
    }
    .sidebar h3 {
      font-size: 1rem;
      margin: 0.5rem 0;
      color: #00d4ff;
      text-shadow: 0 0 6px #00d4ff;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .main-content {
      flex: 1;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: linear-gradient(180deg, rgba(20, 20, 40, 0.7), rgba(10, 10, 30, 0.7));
      min-height: 0;
    }
    .content-wrapper {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
      flex-grow: 1;
      min-height: 0;
    }
    .chart-container, .map-container {
      width: 100%;
      background: rgba(10, 10, 30, 0.9);
      border-radius: 8px;
      box-shadow: 0 4px 15px rgba(0, 212, 255, 0.2), inset 0 0 10px rgba(0, 212, 255, 0.1);
      padding: 0.8rem;
      overflow: hidden;
      height: 50vh;
      border: 1px solid rgba(0, 212, 255, 0.3);
    }
    canvas, #map {
      width: 100% !important;
      height: 100% !important;
      border-radius: 4px;
      box-shadow: inset 0 0 8px rgba(0, 212, 255, 0.2);
    }
    button {
      padding: 0.5rem 0.8rem;
      font-size: 0.85rem;
      cursor: pointer;
      margin: 0.2rem;
      background: linear-gradient(45deg, #00d4ff, #007bff);
      color: #fff;
      border: none;
      border-radius: 4px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: 0 2px 8px rgba(0, 212, 255, 0.4);
      transition: all 0.2s ease;
      min-width: 70px;
      font-family: 'Orbitron', sans-serif;
    }
    button:hover {
      transform: translateY(-1px) scale(1.03);
      box-shadow: 0 4px 12px rgba(0, 212, 255, 0.6);
      background: linear-gradient(45deg, #00eaff, #008cff);
    }
    button.selected {
      background: linear-gradient(45deg, #ff00cc, #ff6699);
      box-shadow: 0 4px 12px rgba(255, 0, 204, 0.6);
    }
    button.selected:hover {
      background: linear-gradient(45deg, #ff33dd, #ff88aa);
    }
    .download-btn {
      padding: 0;
      font-size: 16px;
      background: linear-gradient(45deg, #00d4ff, #007bff);
      border: 1px solid rgba(0, 212, 255, 0.6);
      border-radius: 6px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 6px rgba(0, 212, 255, 0.4);
      transition: all 0.2s ease;
      vertical-align: middle;
      width: 32px;
      height: 32px;
    }
    .download-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 10px rgba(0, 212, 255, 0.6);
      background: linear-gradient(45deg, #00eaff, #008cff);
      border-color: rgba(0, 212, 255, 0.8);
    }
    /* Updated Control Layout Styles */
    .controls-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: 0.5rem;
      margin: 0.5rem 0;
      width: 100%;
      max-width: 100%;
    }
    .control-group {
      display: flex;
      gap: 0.3rem;
      align-items: center;
      background: rgba(10, 10, 30, 0.9);
      padding: 0.3rem;
      border-radius: 6px;
      box-shadow: 0 2px 8px rgba(0, 212, 255, 0.2);
      border: 1px solid rgba(0, 212, 255, 0.3);
    }
    .download-group {
      margin-left: auto;
    }
    @media (max-width: 768px) {
      .controls-container {
        flex-direction: column;
        align-items: stretch;
      }
      .control-group {
        width: 100%;
        justify-content: center;
      }
      .download-group {
        margin-left: 0;
        width: 100%;
        display: flex;
        justify-content: center;
      }
      .download-btn {
        width: 40px;
        height: 40px;
        font-size: 18px;
      }
    }
    @media (min-width: 769px) {
      .controls-container {
        flex-direction: row;
      }
      .control-group {
        flex-wrap: nowrap;
      }
    }
    /* Custom Date Range Slider Styles */
    .date-slider-container {
      width: 80%;
      max-width: 600px;
      margin: 0.5rem auto;
      padding: 0.5rem;
      background: rgba(10, 10, 30, 0.9);
      border-radius: 8px;
      box-shadow: 0 4px 15px rgba(0, 212, 255, 0.2), inset 0 0 10px rgba(0, 212, 255, 0.1);
      border: 1px solid rgba(0, 212, 255, 0.3);
      position: relative;
    }
    .date-slider {
      position: relative;
      height: 8px;
      background: linear-gradient(90deg, #1a1a33, #0d0d1a);
      border-radius: 4px;
      box-shadow: inset 0 0 5px rgba(0, 212, 255, 0.3);
    }
    .date-slider-track {
      position: absolute;
      height: 100%;
      background: linear-gradient(90deg, #00d4ff, #007bff);
      box-shadow: 0 0 8px rgba(0, 212, 255, 0.6);
      border-radius: 4px;
    }
    .date-slider-handle {
      position: absolute;
      width: 16px;
      height: 16px;
      background: linear-gradient(45deg, #00d4ff, #007bff);
      border: 2px solid #fff;
      border-radius: 50%;
      top: -4px;
      cursor: pointer;
      box-shadow: 0 0 8px rgba(0, 212, 255, 0.8);
      transition: transform 0.2s ease;
    }
    .date-slider-handle:hover,
    .date-slider-handle.active {
      transform: scale(1.2);
      background: linear-gradient(45deg, #00eaff, #008cff);
    }
    #dateRangeLabel {
      text-align: center;
      font-size: 0.9rem;
      color: #00d4ff;
      text-shadow: 0 0 6px #00d4ff;
      margin-top: 0.5rem;
      font-family: 'Orbitron', sans-serif;
    }
    /* Rest of your existing styles remain unchanged below */
    .checkbox-group {
      margin-bottom: 0.5rem;
    }
    .checkbox-group summary {
      cursor: pointer;
      font-weight: 600;
      font-size: 1.0rem;
      padding: 0.4rem;
      background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(0, 123, 255, 0.05));
      border-radius: 4px;
      display: flex;
      align-items: center;
      transition: all 0.2s ease;
      color: #00d4ff;
      text-shadow: 0 0 4px rgba(0, 212, 255, 0.5);
    }
    .checkbox-group summary:hover {
      background: linear-gradient(135deg, rgba(0, 212, 255, 0.15), rgba(0, 123, 255, 0.08));
      text-shadow: 0 0 8px rgba(0, 212, 255, 0.7);
    }
    .checkbox-group summary::after {
      content: '▼';
      font-size: 0.7rem;
      margin-left: 0.4rem;
      transition: transform 0.2s ease;
    }
    .checkbox-group[open] summary::after {
      transform: rotate(180deg);
    }
    .checkbox-group input[type="checkbox"] {
      -webkit-appearance: none;
      appearance: none;
      width: 0.9rem;
      height: 0.9rem;
      margin-right: 0.4rem;
      position: relative;
      cursor: pointer;
      background: linear-gradient(135deg, #1a1a33, #0d0d1a);
      border: 1px solid #00d4ff;
      border-radius: 2px;
      transition: all 0.2s ease;
      box-shadow: 0 0 4px rgba(0, 212, 255, 0.3);
    }
    .checkbox-group input[type="checkbox"]:checked {
      background: linear-gradient(135deg, #00d4ff, #007bff);
      box-shadow: 0 0 6px rgba(0, 212, 255, 0.6);
    }
    .checkbox-group input[type="checkbox"]:checked::after {
      content: "✔";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.6rem;
      color: #fff;
      text-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
    }
    .checkbox-group label {
      display: flex;
      align-items: center;
      padding: 0.3rem 0.4rem;
      background: rgba(0, 212, 255, 0.05);
      transition: all 0.2s ease;
      font-size: 0.8rem;
      border-radius: 2px;
    }
    .checkbox-group details label {
      padding-left: 1.2rem;
    }
    .checkbox-group label:hover {
      background: rgba(0, 212, 255, 0.1);
      color: #fff;
    }
    h1 {
      font-size: 1.4rem;
      color: #00d4ff;
      text-shadow: 0 0 10px #00d4ff, 0 0 20px rgba(0, 212, 255, 0.5);
      margin-bottom: 0.5rem;
      text-align: center;
      font-weight: 700;
      letter-spacing: 1.5px;
    }
    p {
      font-size: 0.75rem;
      color: #b0b0b0;
      margin-bottom: 0.8rem;
      text-align: center;
      text-shadow: 0 0 4px rgba(0, 212, 255, 0.3);
    }
    .switch-container {
      margin-bottom: 0.5rem;
      text-align: center;
      width: 100%;
    }
    .structure-buttons {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 100%;
    }
    .structure-btn {
      flex: 1;
      padding: 0.1rem;
      font-size: 0.75rem;
      background: linear-gradient(45deg, #1a1a33, #0d0d1a);
      border: 1px solid #00d4ff;
      border-radius: 4px;
      color: #e0e0e0;
      cursor: pointer;
      text-transform: uppercase;
      transition: all 0.2s ease;
      box-shadow: 0 0 4px rgba(0, 212, 255, 0.3);
    }
    .structure-btn:hover {
      color: #fff;
      box-shadow: 0 2px 8px rgba(0, 212, 255, 0.6);
      background: linear-gradient(45deg, #2a2a4d, #1a1a33);
    }
    .structure-btn.active {
      background: linear-gradient(45deg, #00d4ff, #007bff);
      color: #fff;
      box-shadow: 0 2px 10px rgba(0, 212, 255, 0.7);
    }
    .footer {
      width: 100%;
      text-align: center;
      padding: 0.5rem;
      font-size: 0.65rem;
      font-weight: bold;
      color: #00d4ff;
      text-shadow: 0 0 6px #00d4ff;
      background: none;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      display: inline; /* Keep the heart emoji on the same line */
    }
    .footer span {
      color: #ff3366;
      font-size: 0.85rem;
      text-shadow: 0 0 6px #ff3366;
      display: inline; /* Keep the heart emoji on the same line */
    }
    .footer-buttons {
      display: flex;
      justify-content: center;
      gap: 0.5rem;
    }
    .play-history-btn, .reset-history-btn {
      padding: 0.5rem 1rem;
      font-size: 0.85rem;
      cursor: pointer;
      background: linear-gradient(45deg, #ffcc00, #ff6600);
      color: #fff;
      border: none;
      border-radius: 4px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: 0 2px 8px rgba(255, 204, 0, 0.4);
      transition: all 0.2s ease;
      font-family: 'Orbitron', sans-serif;
      flex: 1;
      text-align: center;
    }
    .play-history-btn:hover {
      transform: translateY(-1px) scale(1.03);
      box-shadow: 0 4px 12px rgba(255, 204, 0, 0.6);
      background: linear-gradient(45deg, #ffdd33, #ff8833);
    }
    .play-history-btn.playing {
      background: linear-gradient(45deg, #ff3366, #cc0033);
      box-shadow: 0 4px 12px rgba(255, 51, 102, 0.6);
    }
    .play-history-btn.playing:hover {
      background: linear-gradient(45deg, #ff5588, #dd2255);
    }
    .reset-history-btn {
      background: linear-gradient(45deg, #ff3366, #cc0033);
      box-shadow: 0 2px 8px rgba(255, 51, 102, 0.4);
    }
    .reset-history-btn:hover {
      transform: translateY(-1px) scale(1.03);
      box-shadow: 0 4px 12px rgba(255, 51, 102, 0.6);
      background: linear-gradient(45deg, #ff5588, #dd2255);
    }
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 10, 30, 0.9);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      backdrop-filter: blur(5px);
    }
    .loading-text {
      font-size: 2rem;
      color: #00d4ff;
      text-shadow: 0 0 10px #00d4ff, 0 0 20px rgba(0, 212, 255, 0.5);
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      letter-spacing: 2px;
      animation: pulse 1.5s infinite ease-in-out;
      position: relative;
    }
    .loading-text::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 150%;
      height: 150%;
      background: radial-gradient(circle, rgba(0, 212, 255, 0.2) 0%, transparent 70%);
      transform: translate(-50%, -50%);
      animation: glow 2s infinite ease-in-out;
      z-index: -1;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.05); opacity: 0.8; }
    }
    @keyframes glow {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 0.5; }
    }
    /* Dialog Box Styles */
    .dialog-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 10, 30, 0.9);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      backdrop-filter: blur(5px);
    }
    .dialog-box {
      background: linear-gradient(135deg, rgba(20, 20, 40, 0.95), rgba(10, 10, 30, 0.95));
      border-radius: 12px;
      padding: 0 1.5rem 1.5rem;
      width: 90%;
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 8px 20px rgba(0, 212, 255, 0.3), inset 0 0 15px rgba(0, 212, 255, 0.1);
      border: 1px solid rgba(0, 212, 255, 0.4);
      animation: fadeIn 0.3s ease-in-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.9); }
      to { opacity: 1; transform: scale(1); }
    }
    .dialog-header {
      position: sticky;
      top: 0;
      background: linear-gradient(135deg, rgba(20, 20, 40, 0.98), rgba(10, 10, 30, 0.98));
      padding: 1rem 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 1;
      border-bottom: 1px solid rgba(0, 212, 255, 0.3);
    }
    .dialog-box h2 {
      font-size: 1.5rem;
      color: #00d4ff;
      text-shadow: 0 0 10px #00d4ff;
      margin: 0;
      font-weight: 700;
      letter-spacing: 1px;
    }
    .event-list {
      list-style: none;
    }
    .event-item {
      background: rgba(0, 212, 255, 0.05);
      padding: 0.8rem;
      margin-bottom: 0.5rem;
      border-radius: 6px;
      transition: all 0.2s ease;
      border: 1px solid rgba(0, 212, 255, 0.2);
    }
    .event-item:hover {
      background: rgba(0, 212, 255, 0.1);
      box-shadow: 0 2px 8px rgba(0, 212, 255, 0.4);
      transform: translateY(-2px);
    }
    .event-item span {
      display: block;
      font-size: 0.9rem;
      color: #e0e0e0;
    }
    .event-item .emoji {
      font-size: 1.2rem;
      margin-right: 0.5rem;
      vertical-align: middle;
    }
    .event-item .date {
      color: #00d4ff;
      font-weight: 600;
      text-shadow: 0 0 4px rgba(0, 212, 255, 0.5);
    }
    .event-item .description {
      font-size: 0.85rem;
      color: #b0b0b0;
    }
    .dialog-close-btn {
      background: none;
      border: none;
      font-size: 1.2rem;
      color: #ff3366;
      text-shadow: 0 0 6px #ff3366;
      padding: 0;
      width: 24px;
      height: 24px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .dialog-close-btn:hover {
      color: #ff5588;
      text-shadow: 0 0 10px #ff5588;
      transform: scale(1.1);
    }
    .sso-history {
      width: 100%;
      text-align: center;
      padding: 0.5rem;
      font-size: 0.8rem;
      color: #00d4ff;
      text-shadow: 0 0 6px #00d4ff;
      background: rgba(10, 10, 30, 0.9);
      border-radius: 4px;
      margin-top: 0.5rem;
      display: none;
    }
    .floating-chart {
      position: fixed;
      top: 20%;
      left: 20px;
      width: 500px;
      height: 400px;
      background: linear-gradient(135deg, rgba(10, 10, 30, 0.95), rgba(20, 20, 40, 0.95));
      border-radius: 12px;
      box-shadow: 0 8px 20px rgba(0, 212, 255, 0.3), inset 0 0 15px rgba(0, 212, 255, 0.2);
      border: 2px solid rgba(0, 212, 255, 0.5);
      z-index: 1500;
      display: none;
      overflow: hidden;
      animation: floatIn 0.5s ease-in-out;
      resize: none;
      min-width: 300px;
      min-height: 200px;
      max-width: 90vw;
      max-height: 90vh;
    }
    .floating-chart-header {
      background: linear-gradient(135deg, rgba(0, 212, 255, 0.2), rgba(0, 123, 255, 0.1));
      padding: 0.5rem;
      cursor: move;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid rgba(0, 212, 255, 0.3);
    }
    .floating-chart-header h3 {
      font-size: 1.1rem;
      color: #00d4ff;
      text-shadow: 0 0 6px #00d4ff;
      margin: 0;
    }
    .floating-chart-close {
      background: none;
      border: none;
      color: #ff3366;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .floating-chart-close:hover {
      color: #ff5588;
      text-shadow: 0 0 10px #ff5588;
    }
    .floating-chart canvas {
      width: 100% !important;
      height: calc(100% - 2.5rem) !important;
      padding: 0.5rem;
    }
    .resize-handle {
      position: absolute;
      bottom: 0;
      right: 0;
      width: 15px;
      height: 15px;
      background: linear-gradient(45deg, #00d4ff, #007bff);
      border-top-left-radius: 50%;
      cursor: se-resize;
      z-index: 1600;
      box-shadow: 0 0 6px rgba(0, 212, 255, 0.6);
    }
    @keyframes floatIn {
      from { opacity: 0; transform: translateY(-20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @media (min-width: 769px) {
      .container {
        flex-direction: row;
      }
      .sidebar {
        width: 250px;
        height: 100vh;
        border-bottom: none;
        border-right: 1px solid rgba(0, 212, 255, 0.4);
        position: fixed;
        top: 0;
        left: 0;
        overflow-y: auto;
        background: linear-gradient(180deg, rgba(20, 20, 40, 0.98), rgba(10, 10, 30, 0.98));
        box-shadow: 2px 0 15px rgba(0, 0, 0, 0.6);
      }
      .sidebar-content {
        display: block;
      }
      .sidebar h3 {
        font-size: 1.1rem;
        margin: 0.6rem 0 0.4rem;
      }
      .main-content {
        flex: 1;
        margin-left: 250px;
        overflow-y: hidden;
        height: 100vh;
        padding: 0.8rem;
      }
      .content-wrapper {
        flex-direction: row;
        height: calc(100% - 5rem);
        margin: 0;
      }
      .chart-container, .map-container {
        flex: 1;
        height: 100%;
        max-height: 100%;
      }
      button {
        padding: 0.6rem 1rem;
        font-size: 0.9rem;
      }
      .download-btn {
        padding: 0;
        font-size: 1.3rem;
      }
      h1 {
        font-size: 1.6rem;
      }
      p {
        font-size: 0.85rem;
      }
      .structure-btn {
        padding: 0.5rem;
        font-size: 0.8rem;
      }
      .checkbox-group summary {
        font-size: 1rem;
        padding: 0.5rem;
      }
      .checkbox-group input[type="checkbox"] {
        width: 1rem;
        height: 1rem;
      }
      .checkbox-group label {
        padding: 0.4rem 0.5rem;
        font-size: 1rem;
      }
      .loading-text {
        font-size: 2.5rem;
      }
      .dialog-box h2 {
        font-size: 1.8rem;
      }
      .event-item span {
        font-size: 1rem;
      }
      .event-item .emoji {
        font-size: 1.4rem;
      }
      .event-item .description {
        font-size: 0.9rem;
      }
      .play-history-btn, .reset-history-btn {
        padding: 0.6rem 1rem;
        font-size: 0.9rem;
      }
      .sso-history {
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>
  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-text">Initializing Data...</div>
  </div>
  <div class="dialog-overlay" id="eventsDialog">
    <div class="dialog-box">
      <div class="dialog-header">
        <h2>Special Weather Events</h2>
        <button class="dialog-close-btn" id="closeEventsDialog">✖</button>
      </div>
      <ul class="event-list" id="eventList"></ul>
    </div>
  </div>
  <div class="floating-chart" id="cumulativeChartContainer">
    <div class="floating-chart-header" id="floatingChartHeader">
      <h3>Cumulative SSO</h3>
      <button class="floating-chart-close" id="closeCumulativeChart">✖</button>
    </div>
    <canvas id="cumulativeSSOChart"></canvas>
    <div class="resize-handle" id="resizeHandle"></div>
  </div>
  <div class="container">
    <details class="sidebar" id="mobile-sidebar">
      <summary>Filter</summary>
      <div class="sidebar-content">
        <h3>SSO by Struct. Type</h3>
        <div class="switch-container">
          <div class="structure-buttons">
            <button class="structure-btn active" data-type="All" title="Show all SSO Structure types">All</button>
            <button class="structure-btn" data-type="Main" title="Show SSO from Main Sewer">Main</button>
            <button class="structure-btn" data-type="Lateral" title="Show SSO from Service Laterals">SLat</button>
          </div>
        </div>
        <h3>SSO by Cause</h3>
        <div id="causeCheckboxes"></div>
        <div class="footer">
          <div class="footer-buttons">
            <button id="playHistoryBtnMobile" class="play-history-btn" style="display: none;">Play SSO History</button>
            <button id="resetHistoryBtnMobile" class="reset-history-btn" style="display: none;">Reset</button>
          </div>
          <hr style="border: none; height: 1px; background: linear-gradient(to right, #002855, #0056b3); width: 100%;" />
          Drought Data source: U.S. Drought Monitor
        </div>
      </div>
    </details>
    <div class="sidebar" id="desktop-sidebar" style="display: none;">
      <div class="sidebar-content">
        <h3>SSO by Struct. Type</h3>
        <div class="switch-container">
          <div class="structure-buttons">
            <button class="structure-btn active" data-type="All" title="Show all SSO Structure types">All</button>
            <button class="structure-btn" data-type="Main" title="Show SSO from Main Sewer">Main</button>
            <button class="structure-btn" data-type="Lateral" title="Show SSO from Service Laterals">SLat</button>
          </div>
        </div>
        <h3>SSO by Cause</h3>
        <div id="causeCheckboxesDesktop"></div>
        <div class="footer">
          <div class="footer-buttons">
            <button id="playHistoryBtnDesktop" class="play-history-btn" style="display: none;">Play SSO History</button>
            <button id="resetHistoryBtnDesktop" class="reset-history-btn" style="display: none;">Reset</button>
          </div>
          <hr style="border: none; height: 1px; background: linear-gradient(to right, #002855, #0056b3); width: 100%;" />
          Drought Data source: U.S. Drought Monitor
        </div>
      </div>
    </div>
    <div class="main-content">
      <h1>COH - Drought & Public Sewer Overflow Awareness</h1>
      <div class="date-slider-container">
        <div class="date-slider" id="dateSlider">
          <div class="date-slider-track" id="dateSliderTrack"></div>
          <div class="date-slider-handle" id="dateSliderMin"></div>
          <div class="date-slider-handle" id="dateSliderMax"></div>
        </div>
        <div id="dateRangeLabel"></div>
      </div>
      <div class="controls-container">
        <div class="control-group">
          <button id="weeklyBtn">Weekly</button>
          <button id="monthlyBtn" class="selected">Monthly</button>
          <button id="yearlyBtn">Yearly</button>
          <button id="resetZoomBtn">Reset Zoom</button>
        </div>
        <div class="control-group">
          <button id="toggleMapBtn">Hide Map</button>
          <button id="showEventsBtn">Show Events</button>
        </div>
        <div class="control-group download-group">
          <button id="downloadBtn" class="download-btn" title="Download Chart Data as CSV">↓</button>
        </div>
      </div>
      <div class="content-wrapper">
        <div class="chart-container">
          <canvas id="droughtChart"></canvas>
        </div>
        <div class="map-container">
          <div id="map"></div>
        </div>
      </div>
      <div class="sso-history" id="ssoHistory">[2019-01 -> Current]</div>
      <div class="footer">
        Made with <span>❤</span> by HN - 2025 - Disclaimer: Data provided 'as is' for informational use only.
      </div>
    </div>
  </div>
  <script>
    const droughtApiUrl = "https://services9.arcgis.com/RHVPKKiFTONKtxq3/ArcGIS/rest/services/US_Drought_Intensity_v1/FeatureServer/1/query" +
      "?where=admin_fips%3D48201" +
      "&outFields=*" +
      "&f=json";
    const ssoApiUrl = "https://services.arcgis.com/NummVBqZSIJKUeVR/arcgis/rest/services/RSSO_Package/FeatureServer/0/query";

    let rawDroughtData = [];
    let rawSSOFeatures = [];
    let myChart, mapView, cumulativeChart;
    let uniqueCauses = [];
    let selectedCauses = new Set();
    let selectedStructureGroup = "All";
    let currentPeriod = 'monthly';
    let selectedDateRange = { start: new Date("2024-01-01"), end: new Date("2025-03-16") };
    let mapVisible = true;
    let isPlaying = false;
    let animationInterval = null;
    let currentAnimationDate = new Date("2019-01-01");
    let animationIndex = 0;

    const sewerMainTypes = ["Manhole", "Lift Station", "Gravity Main", "Force Main", "Treatment Plant"];

    const specialWeatherEvents = [
      { event: "Tropical Storm Imelda", date: new Date("2019-09-19"), emoji: "⛈️" },
      { event: "Hurricane Laura (Outer Bands)", date: new Date("2020-08-27"), emoji: "🌀" },
      { event: "Hurricane Beta (Outer Bands)", date: new Date("2020-09-21"), emoji: "🌀" },
      { event: "Winter Storm Uri", date: new Date("2021-02-15"), emoji: "❄️" },
      { event: "Hurricane Nicholas", date: new Date("2021-09-14"), emoji: "🌀" },
      { event: "Severe Thunderstorms and Tornadoes", date: new Date("2023-01-24"), emoji: "🌪️" },
      { event: "Extreme Heat and Drought", date: new Date("2023-08-01"), emoji: "☀️" },
      { event: "Hurricane Beryl", date: new Date("2024-07-08"), emoji: "🌀" },
      { event: "Derecho", date: new Date("2024-05-16"), emoji: "💨" },
      { event: "Winter Storm (Snow and Extreme Cold)", date: new Date("2025-01-20"), emoji: "❄️" }
    ];

    const structureGroups = {
      "All": { color: "#FFFFFF", outline: "#CCCCCC" },
      "Main": { color: "#00FF99", outline: "#00CC77" },
      "Service Lateral": { color: "#FF00CC", outline: "#CC0099" }
    };

    function showLoading() { document.getElementById("loadingOverlay").style.display = "flex"; }
    function hideLoading() { document.getElementById("loadingOverlay").style.display = "none"; }

    function fetchDroughtData() {
      return fetch(droughtApiUrl)
        .then(response => response.ok ? response.json() : Promise.reject("Drought data error: " + response.status))
        .then(json => {
          if (!json.features || json.features.length === 0) throw new Error("No drought features returned");
          return json.features
            .map(f => ({
              date: new Date(f.attributes.ddate),
              d4: f.attributes.d4 || 0, d3: f.attributes.d3 || 0, d2: f.attributes.d2 || 0,
              d1: f.attributes.d1 || 0, d0: f.attributes.d0 || 0, none: f.attributes.nothing || 0
            }))
            .filter(r => r.date >= new Date("2019-01-01"))
            .sort((a, b) => a.date - b.date);
        });
    }

    function fetchSSOData(resultOffset = 0, accumulated = []) {
      const queryParams = new URLSearchParams({
        where: "System LIKE '%ublic%' AND STARTDATE >= date '2019-01-01'",
        outFields: "*", f: "json", returnGeometry: true, resultOffset: resultOffset, resultRecordCount: 2000, orderByFields: "STARTDATE ASC"
      });
      return fetch(ssoApiUrl + "?" + queryParams.toString())
        .then(response => response.ok ? response.json() : Promise.reject("SSO data error: " + response.status))
        .then(json => {
          if (!json.features) return accumulated;
          accumulated.push(...json.features);
          if (json.exceededTransferLimit) return fetchSSOData(resultOffset + 2000, accumulated);
          return accumulated;
        });
    }

    function normalizeCause(cause) { return cause ? cause.toLowerCase().replace(/–/g, "-").replace(/\s+/g, " ").trim() : "Unknown"; }

    function groupCauses(causes) {
      const grouped = { "Grease": [], "Rags/Wipes": [], "Roots": [], "Structural Issues": [], "Blockages": [],
        "Wet Weather": [], "Lift Station/Treatment Plant/Power": [], "Cross Connections": [], "Other": [], "Unknown": [] };
      causes.forEach(cause => {
        const normalized = normalizeCause(cause);
        const original = cause || "Unknown";
        if (normalized.includes("grease blockage")) grouped["Grease"].push(original);
        else if (normalized.includes("rags/wipes")) grouped["Rags/Wipes"].push(original);
        else if (normalized.includes("roots")) grouped["Roots"].push(original);
        else if (normalized.includes("pump/lift station") || normalized.includes("wwtp") || normalized.includes("power outage")) grouped["Lift Station/Treatment Plant/Power"].push(original);
        else if (normalized.includes("structural failure") || normalized.includes("structural blockage")) grouped["Structural Issues"].push(original);
        else if (normalized.includes("temporary blockage")) grouped["Blockages"].push(original);
        else if (normalized.includes("wet weather")) grouped["Wet Weather"].push(original);
        else if (normalized.includes("cross connection") || normalized.includes("cross-connection")) grouped["Cross Connections"].push(original);
        else if (normalized === "unknown") grouped["Unknown"].push(original);
        else grouped["Other"].push(original);
      });
      for (const group in grouped) grouped[group].sort();
      return grouped;
    }

    function createStructureTypeSwitch(containerSelector) {
      const buttons = document.querySelectorAll(`${containerSelector} .structure-btn`);
      buttons.forEach(button => {
        button.addEventListener('click', () => {
          buttons.forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');
          selectedStructureGroup = button.getAttribute('data-type') === "All" ? "All" :
                                   button.getAttribute('data-type') === "Main" ? "Main" : "Service Lateral";
          updateChartWithCurrentPeriod();
          updateMap();
        });
      });
    }

    function createCauseCheckboxes(containerId) {
      if (!rawSSOFeatures || rawSSOFeatures.length === 0) {
        document.getElementById(containerId).innerHTML = "<p>No data available</p>";
        return;
      }
      uniqueCauses = [...new Set(rawSSOFeatures.map(f => f.attributes.CAUSE))];
      const groupedCauses = groupCauses(uniqueCauses);
      const container = document.getElementById(containerId);
      container.innerHTML = "";
      const allCheckbox = document.createElement("div");
      allCheckbox.className = "checkbox-group";
      allCheckbox.innerHTML = `<label><input type="checkbox" id="cause-all-${containerId}" checked> All</label>`;
      container.appendChild(allCheckbox);

      const categoryOrder = ["Grease", "Rags/Wipes", "Roots", "Structural Issues", "Blockages",
                            "Wet Weather", "Lift Station/Treatment Plant/Power", "Cross Connections", "Other", "Unknown"];
      categoryOrder.forEach(category => {
        const causes = groupedCauses[category];
        if (causes.length === 0) return;
        const details = document.createElement("details");
        details.className = "checkbox-group";
        details.innerHTML = `<summary><input type="checkbox" class="category-checkbox" data-category="${category}" checked> ${category}</summary>`;
        causes.forEach(cause => {
          details.innerHTML += `<label><input type="checkbox" class="cause-checkbox" data-cause="${cause || 'Unknown'}" checked> ${cause || 'Unknown'}</label>`;
          selectedCauses.add(cause || 'Unknown');
        });
        const categoryCheckbox = details.querySelector(".category-checkbox");
        categoryCheckbox.addEventListener("change", (e) => {
          const isChecked = e.target.checked;
          details.querySelectorAll(".cause-checkbox").forEach(cb => {
            cb.checked = isChecked;
            const cause = cb.getAttribute("data-cause");
            isChecked ? selectedCauses.add(cause) : selectedCauses.delete(cause);
          });
          updateAllCheckbox();
          updateChartWithCurrentPeriod();
          updateMap();
        });
        details.querySelectorAll(".cause-checkbox").forEach(cb => {
          cb.addEventListener("change", (e) => {
            const cause = e.target.getAttribute("data-cause");
            e.target.checked ? selectedCauses.add(cause) : selectedCauses.delete(cause);
            const allChecked = [...details.querySelectorAll(".cause-checkbox")].every(c => c.checked);
            categoryCheckbox.checked = allChecked;
            updateAllCheckbox();
            updateChartWithCurrentPeriod();
            updateMap();
          });
        });
        container.appendChild(details);
      });

      document.getElementById(`cause-all-${containerId}`).addEventListener("change", (e) => {
        const isChecked = e.target.checked;
        container.querySelectorAll(".cause-checkbox, .category-checkbox").forEach(cb => {
          cb.checked = isChecked;
          if (cb.classList.contains("cause-checkbox")) {
            const cause = cb.getAttribute("data-cause");
            isChecked ? selectedCauses.add(cause) : selectedCauses.delete(cause);
          }
        });
        updateChartWithCurrentPeriod();
        updateMap();
      });

      function updateAllCheckbox() {
        const allCheckbox = document.getElementById(`cause-all-${containerId}`);
        if (allCheckbox) {
          allCheckbox.checked = categoryOrder.every(cat => {
            const catCheckbox = container.querySelector(`[data-category="${cat}"]`);
            return !catCheckbox || catCheckbox.checked;
          });
        }
      }
    }

    function aggregateData(data, period) {
      const filteredData = data.filter(r => r.date >= selectedDateRange.start && r.date <= selectedDateRange.end);
      if (period === 'weekly') return filteredData;
      const groups = {};
      filteredData.forEach(record => {
        const date = new Date(record.date);
        const key = period === 'monthly' ? `${date.getFullYear()}-${date.getMonth() + 1}` : `${date.getFullYear()}`;
        groups[key] = groups[key] || [];
        groups[key].push(record);
      });
      return Object.entries(groups).map(([key, group]) => {
        const sum = group.reduce((acc, cur) => ({
          d4: acc.d4 + cur.d4, d3: acc.d3 + cur.d3, d2: acc.d2 + cur.d2,
          d1: acc.d1 + cur.d1, d0: acc.d0 + cur.d0, none: acc.none + cur.none
        }), { d4: 0, d3: 0, d2: 0, d1: 0, d0: 0, none: 0 });
        const count = group.length;
        return {
          date: group[0].date,
          d4: sum.d4 / count, d3: sum.d3 / count, d2: sum.d2 / count,
          d1: sum.d1 / count, d0: sum.d0 / count, none: sum.none / count
        };
      }).sort((a, b) => a.date - b.date);
    }

    function getWeekEndDate(date) {
      const d = new Date(date);
      d.setDate(d.getDate() + (6 - d.getDay()));
      return d;
    }

    function aggregateSSOData(features, period) {
      let filteredFeatures = features.filter(f => new Date(f.attributes.STARTDATE) >= selectedDateRange.start && new Date(f.attributes.STARTDATE) <= selectedDateRange.end);
      if (selectedStructureGroup === "Main") filteredFeatures = filteredFeatures.filter(f => sewerMainTypes.includes(f.attributes.STRUCTURETYPE));
      else if (selectedStructureGroup === "Service Lateral") filteredFeatures = filteredFeatures.filter(f => !sewerMainTypes.includes(f.attributes.STRUCTURETYPE) || !f.attributes.STRUCTURETYPE);
      filteredFeatures = selectedCauses.size === 0 || selectedCauses.size === uniqueCauses.length ? filteredFeatures : filteredFeatures.filter(f => selectedCauses.has(f.attributes.CAUSE || 'Unknown'));

      const groups = {};
      filteredFeatures.forEach(f => {
        const eventDate = new Date(f.attributes.STARTDATE);
        let key, repDate;
        if (period === 'weekly') {
          const weekEnd = getWeekEndDate(eventDate);
          key = weekEnd.toISOString();
          repDate = weekEnd;
        } else if (period === 'monthly') {
          key = `${eventDate.getFullYear()}-${eventDate.getMonth() + 1}`;
          repDate = new Date(eventDate.getFullYear(), eventDate.getMonth(), 1);
        } else if (period === 'yearly') {
          key = `${eventDate.getFullYear()}`;
          repDate = new Date(eventDate.getFullYear(), 0, 1);
        }
        groups[key] = groups[key] || { date: repDate, count: 0 };
        groups[key].count += 1;
      });
      return Object.values(groups).sort((a, b) => a.date - b.date);
    }

    function aggregateCumulativeSSOData(features, endDate) {
      let filteredFeatures = features.filter(f => new Date(f.attributes.STARTDATE) <= endDate && new Date(f.attributes.STARTDATE) >= selectedDateRange.start);
      if (selectedStructureGroup === "Main") filteredFeatures = filteredFeatures.filter(f => sewerMainTypes.includes(f.attributes.STRUCTURETYPE));
      else if (selectedStructureGroup === "Service Lateral") filteredFeatures = filteredFeatures.filter(f => !sewerMainTypes.includes(f.attributes.STRUCTURETYPE) || !f.attributes.STRUCTURETYPE);
      filteredFeatures = selectedCauses.size === 0 || selectedCauses.size === uniqueCauses.length ? filteredFeatures : filteredFeatures.filter(f => selectedCauses.has(f.attributes.CAUSE || 'Unknown'));

      const monthlyGroups = {};
      filteredFeatures.forEach(f => {
        const eventDate = new Date(f.attributes.STARTDATE);
        const key = `${eventDate.getFullYear()}-${eventDate.getMonth() + 1}`;
        monthlyGroups[key] = monthlyGroups[key] || { date: new Date(eventDate.getFullYear(), eventDate.getMonth(), 1), count: 0 };
        monthlyGroups[key].count += 1;
      });

      const sortedGroups = Object.values(monthlyGroups).sort((a, b) => a.date - b.date);
      let cumulativeCount = 0;
      return sortedGroups.map(group => {
        cumulativeCount += group.count;
        return { date: group.date, count: cumulativeCount };
      });
    }

    function formatDateForDisplay(date) {
      const d = new Date(date);
      return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
    }

    function formatMonthForDisplay(date) {
      const d = new Date(date);
      return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
    }

    function getPeriodDateRange(date, period) {
      const startDate = new Date(date);
      const endDate = new Date(startDate);
      if (period === 'weekly') endDate.setDate(startDate.getDate() + 6);
      else if (period === 'monthly') endDate.setMonth(startDate.getMonth() + 1, 0);
      else if (period === 'yearly') endDate.setFullYear(startDate.getFullYear() + 1, 11, 31);
      return { start: startDate, end: endDate };
    }

    function updateChart(aggDrought, aggSSO) {
      myChart.data.datasets[0].data = aggDrought.map(r => ({ x: r.date, y: r.d4 }));
      myChart.data.datasets[1].data = aggDrought.map(r => ({ x: r.date, y: r.d3 }));
      myChart.data.datasets[2].data = aggDrought.map(r => ({ x: r.date, y: r.d2 }));
      myChart.data.datasets[3].data = aggDrought.map(r => ({ x: r.date, y: r.d1 }));
      myChart.data.datasets[4].data = aggDrought.map(r => ({ x: r.date, y: r.d0 }));
      myChart.data.datasets[5].data = aggSSO.map(r => ({ x: r.date, y: r.count }));
      myChart.options.plugins.title.text = `Drought & Public Sewer Overflow (${currentPeriod.charAt(0).toUpperCase() + currentPeriod.slice(1)})`;
      myChart.options.plugins.annotation.annotations = [
        ...specialWeatherEvents.filter(e => e.date >= selectedDateRange.start && e.date <= selectedDateRange.end).map((e, i) => ({
          type: 'label', xValue: e.date, yValue: 100, content: e.emoji, color: '#ffffff', font: { size: 20 }, position: 'center', xAdjust: 0, yAdjust: -5, backgroundColor: 'rgba(0, 0, 0, 0)', borderWidth: 0
        })),
        {
          type: 'line', id: 'cursorLine', mode: 'vertical', scaleID: 'x', value: aggSSO[aggSSO.length - 1].date,
          borderColor: '#00d4ff', borderWidth: 2, label: { enabled: true, content: formatDateForDisplay(aggSSO[aggSSO.length - 1].date), position: 'top', backgroundColor: 'rgba(0, 212, 255, 0.8)', font: { size: 12 } }
        }
      ];
      myChart.update();
    }

    function updateChartWithCurrentPeriod() {
      const aggDrought = aggregateData(rawDroughtData, currentPeriod);
      const aggSSO = aggregateSSOData(rawSSOFeatures, currentPeriod);
      updateChart(aggDrought, aggSSO);
      document.querySelectorAll("#weeklyBtn, #monthlyBtn, #yearlyBtn").forEach(btn => btn.classList.remove("selected"));
      document.getElementById(`${currentPeriod}Btn`).classList.add("selected");
    }

    function initializeMap() {
      return new Promise((resolve, reject) => {
        require(["esri/Map", "esri/views/MapView", "esri/layers/FeatureLayer", "esri/widgets/Legend", "esri/widgets/Expand"],
        (Map, MapView, FeatureLayer, Legend, Expand) => {
          const ssoLayer = new FeatureLayer({
            url: "https://services.arcgis.com/NummVBqZSIJKUeVR/arcgis/rest/services/RSSO_Package/FeatureServer/0",
            outFields: ["*"], definitionExpression: "System LIKE '%ublic%' AND STARTDATE >= '2019-01-01'",
            renderer: {
              type: "unique-value",
              valueExpression: `var structureType = $feature.STRUCTURETYPE; if (IsEmpty(structureType)) return 'Service Lateral'; if (Includes(['Manhole', 'Lift Station', 'Gravity Main', 'Force Main', 'Treatment Plant'], structureType)) return 'Main'; return 'Service Lateral';`,
              uniqueValueInfos: [
                { value: "Main", symbol: { type: "simple-marker", color: structureGroups["Main"].color, size: 8, outline: { color: structureGroups["Main"].outline, width: 1.5 } } },
                { value: "Service Lateral", symbol: { type: "simple-marker", color: structureGroups["Service Lateral"].color, size: 8, outline: { color: structureGroups["Service Lateral"].outline, width: 1.5 } } }
              ],
              defaultSymbol: { type: "simple-marker", color: structureGroups["All"].color, size: 8, outline: { color: structureGroups["All"].outline, width: 1.5 } }
            }
          });
          const map = new Map({ basemap: "streets-night-vector", layers: [ssoLayer] });
          mapView = new MapView({ container: "map", map: map, center: [-95.3632715, 29.7632836], zoom: 10 });
          const legend = new Legend({ view: mapView, layerInfos: [{ layer: ssoLayer, title: "SSO Events by Structure Type" }] });
          const legendExpand = new Expand({ view: mapView, content: legend, expanded: false, expandTooltip: "Show Legend", collapseTooltip: "Hide Legend" });
          mapView.ui.add(legendExpand, "top-right");
          mapView.when(() => { updateMap(); resolve(); }).catch(err => reject(err));
        }, err => reject(err));
      });
    }
	    function updateMap() {
      if (!mapView) return;
      require(["esri/layers/FeatureLayer"], (FeatureLayer) => {
        const ssoLayer = mapView.map.layers.find(layer => layer.url.includes("RSSO_Package"));
        if (!ssoLayer) return;
        let ssoWhereClause = `System LIKE '%ublic%' AND STARTDATE >= '${formatDateForDisplay(selectedDateRange.start)}' AND STARTDATE <= '${formatDateForDisplay(selectedDateRange.end)}'`;
        if (selectedStructureGroup === "Main") ssoWhereClause += ` AND STRUCTURETYPE IN ('${sewerMainTypes.join("','")}')`;
        else if (selectedStructureGroup === "Service Lateral") ssoWhereClause += ` AND (STRUCTURETYPE NOT IN ('${sewerMainTypes.join("','")}') OR STRUCTURETYPE IS NULL)`;
        if (selectedCauses.size > 0 && selectedCauses.size < uniqueCauses.length) {
          const causesArray = Array.from(selectedCauses).map(c => c === "Unknown" ? "CAUSE IS NULL" : `CAUSE = '${c}'`);
          ssoWhereClause += ` AND (${causesArray.join(" OR ")})`;
        }
        ssoLayer.definitionExpression = ssoWhereClause;
      });
    }

    function updateMapCumulative(endDate) {
      if (!mapView) return;
      require(["esri/layers/FeatureLayer"], (FeatureLayer) => {
        const ssoLayer = mapView.map.layers.find(layer => layer.url.includes("RSSO_Package"));
        if (!ssoLayer) return;
        let ssoWhereClause = `System LIKE '%ublic%' AND STARTDATE >= '${formatDateForDisplay(selectedDateRange.start)}' AND STARTDATE <= '${formatDateForDisplay(endDate)}'`;
        if (selectedStructureGroup === "Main") ssoWhereClause += ` AND STRUCTURETYPE IN ('${sewerMainTypes.join("','")}')`;
        else if (selectedStructureGroup === "Service Lateral") ssoWhereClause += ` AND (STRUCTURETYPE NOT IN ('${sewerMainTypes.join("','")}') OR STRUCTURETYPE IS NULL)`;
        if (selectedCauses.size > 0 && selectedCauses.size < uniqueCauses.length) {
          const causesArray = Array.from(selectedCauses).map(c => c === "Unknown" ? "CAUSE IS NULL" : `CAUSE = '${c}'`);
          ssoWhereClause += ` AND (${causesArray.join(" OR ")})`;
        }
        ssoLayer.definitionExpression = ssoWhereClause;
        ssoLayer.renderer = {
          type: "simple",
          symbol: { type: "simple-marker", style: "diamond", color: [255, 255, 0, 0.9], size: 6, outline: { color: [255, 153, 0, 1], width: 1.5 }, haloColor: [255, 255, 255, 0.7], haloSize: 3, effect: "bloom(1.5, 0.5px, 0.1)" }
        };
        const historyDiv = document.getElementById("ssoHistory");
        historyDiv.style.display = "block";
        const structureText = selectedStructureGroup === "All" ? "All Structures" : selectedStructureGroup;
        let causesText = selectedCauses.size === 0 || selectedCauses.size === uniqueCauses.length ? "All Causes" : Object.keys(groupCauses(Array.from(selectedCauses))).filter(group => groupCauses(Array.from(selectedCauses))[group].length > 0).join(", ");
        historyDiv.textContent = `[${formatMonthForDisplay(selectedDateRange.start)} -> ${formatMonthForDisplay(endDate)}] | ${structureText} | ${causesText}`;
      });
    }

    function resetMapToNormal() {
      updateMap();
      if (!mapView) return;
      require(["esri/layers/FeatureLayer"], (FeatureLayer) => {
        const ssoLayer = mapView.map.layers.find(layer => layer.url.includes("RSSO_Package"));
        if (ssoLayer) {
          ssoLayer.renderer = {
            type: "unique-value",
            valueExpression: `var structureType = $feature.STRUCTURETYPE; if (IsEmpty(structureType)) return 'Service Lateral'; if (Includes(['Manhole', 'Lift Station', 'Gravity Main', 'Force Main', 'Treatment Plant'], structureType)) return 'Main'; return 'Service Lateral';`,
            uniqueValueInfos: [
              { value: "Main", symbol: { type: "simple-marker", color: structureGroups["Main"].color, size: 8, outline: { color: structureGroups["Main"].outline, width: 1.5 } } },
              { value: "Service Lateral", symbol: { type: "simple-marker", color: structureGroups["Service Lateral"].color, size: 8, outline: { color: structureGroups["Service Lateral"].outline, width: 1.5 } } }
            ],
            defaultSymbol: { type: "simple-marker", color: structureGroups["All"].color, size: 8, outline: { color: structureGroups["All"].outline, width: 1.5 } }
          };
        }
      });
      const historyDiv = document.getElementById("ssoHistory");
      historyDiv.style.display = "none";
      historyDiv.textContent = `[${formatMonthForDisplay(selectedDateRange.start)} -> ${formatMonthForDisplay(selectedDateRange.end)}]`;
    }

    function initializeCumulativeChart() {
      const ctx = document.getElementById("cumulativeSSOChart").getContext("2d");
      cumulativeChart = new Chart(ctx, {
        type: "line",
        data: {
          datasets: [
            { label: "Cumulative SSO", data: [], borderColor: "#00ff00", backgroundColor: "rgba(0, 255, 0, 0.2)", fill: true, tension: 0.1, pointRadius: 0, pointHitRadius: 10 },
            { label: "Weather Events", data: [], type: "scatter", pointStyle: "circle", pointRadius: 8, pointBackgroundColor: "#ff3366", pointBorderColor: "#ffffff", pointBorderWidth: 2, showLine: false, pointHitRadius: 15 }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: { padding: { bottom: 40 } },
          scales: {
            x: { type: "time", time: { unit: "month", displayFormats: { month: "MMM yyyy" }, tooltipFormat: "yyyy-MM-dd" }, ticks: { color: "#00d4ff", maxRotation: 45, minRotation: 45, autoSkip: true, maxTicksLimit: 12, font: { size: 12, family: 'Orbitron' }, padding: 10 }, grid: { color: "rgba(0, 212, 255, 0.2)" } },
            y: { min: 0, ticks: { color: "#00d4ff", font: { family: 'Orbitron' } }, grid: { color: "rgba(0, 212, 255, 0.2)" } }
          },
          plugins: {
            legend: { labels: { color: "#00d4ff", font: { family: 'Orbitron' } } },
            title: { display: true, text: "Cumulative SSO Over Time", color: "#00d4ff", font: { size: 14, family: 'Orbitron' } },
            tooltip: {
              enabled: true, mode: "index", intersect: false, position: "nearest", backgroundColor: "rgba(10, 10, 30, 0.95)",
              titleFont: { family: "Orbitron", size: 14, weight: "bold" }, bodyFont: { family: "Orbitron", size: 12 }, padding: 10, cornerRadius: 6,
              borderColor: "rgba(0, 212, 255, 0.5)", borderWidth: 1, titleColor: "#00d4ff", bodyColor: "#e0e0e0",
              callbacks: {
                title: (tooltipItems) => formatDateForDisplay(new Date(tooltipItems[0].raw.x)),
                label: (ctx) => ctx.dataset.label === "Cumulative SSO" ? `Cumulative SSO: ${ctx.parsed.y}` : (ctx.dataset.label === "Weather Events" && ctx.raw.event ? `${ctx.raw.event} (${formatDateForDisplay(ctx.raw.x)})` : "")
              }
            }
          }
        }
      });
    }

    function updateCumulativeChart(endDate) {
      const cumulativeData = aggregateCumulativeSSOData(rawSSOFeatures, endDate);
      const weatherData = specialWeatherEvents
        .filter(event => event.date <= endDate && event.date >= selectedDateRange.start)
        .map(event => {
          const closestCumulative = cumulativeData.reduce((prev, curr) => Math.abs(curr.date - event.date) < Math.abs(prev.date - event.date) ? curr : prev);
          return { x: event.date, y: closestCumulative.count, event: event.event, emoji: event.emoji };
        });

      cumulativeChart.data.datasets[0].data = cumulativeData.map(d => ({ x: d.date, y: d.count }));
      cumulativeChart.data.datasets[1].data = weatherData.map(d => ({ x: d.x, y: d.y, event: d.event }));
      cumulativeChart.options.plugins.annotation = {
        annotations: weatherData.map((d, i) => ({
          type: 'label', xValue: d.x, yValue: d.y, content: d.emoji, color: '#ff3366', font: { size: 16 }, position: 'center', xAdjust: 0, yAdjust: -20, backgroundColor: 'rgba(0, 0, 0, 0)', borderWidth: 0
        }))
      };
      cumulativeChart.update();
    }

    function toggleHistoryAnimation() {
      const playBtnMobile = document.getElementById("playHistoryBtnMobile");
      const playBtnDesktop = document.getElementById("playHistoryBtnDesktop");
      const resetBtnMobile = document.getElementById("resetHistoryBtnMobile");
      const resetBtnDesktop = document.getElementById("resetHistoryBtnDesktop");
      const playBtn = window.innerWidth <= 768 ? playBtnMobile : playBtnDesktop;
      const resetBtn = window.innerWidth <= 768 ? resetBtnMobile : resetBtnDesktop;

      if (!isPlaying) {
        isPlaying = true;
        playBtn.textContent = "Pause";
        playBtn.classList.add("playing");
        resetBtn.style.display = "block";
        document.getElementById("cumulativeChartContainer").style.display = "block";
        const monthlyDates = getMonthlyDates(selectedDateRange.start, selectedDateRange.end);
        if (animationInterval) clearInterval(animationInterval);

        animationIndex = 0;
        currentAnimationDate = monthlyDates[0];
        animationInterval = setInterval(() => {
          if (animationIndex >= monthlyDates.length) {
            clearInterval(animationInterval);
            isPlaying = false;
            playBtn.textContent = "Play SSO History";
            playBtn.classList.remove("playing");
            animationIndex = 0;
            return;
          }
          currentAnimationDate = monthlyDates[animationIndex];
          updateMapCumulative(currentAnimationDate);
          updateCumulativeChart(currentAnimationDate);
          animationIndex++;
        }, 200);
      } else {
        isPlaying = false;
        playBtn.textContent = "Resume";
        playBtn.classList.remove("playing");
        clearInterval(animationInterval);
      }
    }

    function resetHistoryAnimation() {
      const playBtnMobile = document.getElementById("playHistoryBtnMobile");
      const playBtnDesktop = document.getElementById("playHistoryBtnDesktop");
      const resetBtnMobile = document.getElementById("resetHistoryBtnMobile");
      const resetBtnDesktop = document.getElementById("resetHistoryBtnDesktop");
      const playBtn = window.innerWidth <= 768 ? playBtnMobile : playBtnDesktop;
      const resetBtn = window.innerWidth <= 768 ? resetBtnMobile : resetBtnDesktop;

      isPlaying = false;
      clearInterval(animationInterval);
      playBtn.textContent = "Play SSO History";
      playBtn.classList.remove("playing");
      resetBtn.style.display = "none";
      document.getElementById("cumulativeChartContainer").style.display = "none";
      resetMapToNormal();
      animationIndex = 0;
      currentAnimationDate = selectedDateRange.start;
    }

    function makeChartDraggable() {
      const chart = document.getElementById("cumulativeChartContainer");
      const header = document.getElementById("floatingChartHeader");
      let isDragging = false, currentX, currentY, initialX, initialY;

      header.addEventListener("mousedown", (e) => {
        isDragging = true;
        initialX = e.clientX - currentX;
        initialY = e.clientY - currentY;
        header.style.cursor = "grabbing";
      });

      document.addEventListener("mousemove", (e) => {
        if (isDragging) {
          e.preventDefault();
          currentX = e.clientX - initialX;
          currentY = e.clientY - initialY;
          chart.style.left = `${currentX}px`;
          chart.style.top = `${currentY}px`;
        }
      });

      document.addEventListener("mouseup", () => {
        isDragging = false;
        header.style.cursor = "move";
      });

      currentX = parseInt(window.getComputedStyle(chart).left) || 20;
      currentY = parseInt(window.getComputedStyle(chart).top) || 20 * window.innerHeight / 100;
    }

    function makeChartResizable() {
      const chart = document.getElementById("cumulativeChartContainer");
      const resizeHandle = document.getElementById("resizeHandle");
      let isResizing = false, startX, startY, startWidth, startHeight;

      resizeHandle.addEventListener("mousedown", (e) => {
        isResizing = true;
        startX = e.clientX;
        startY = e.clientY;
        startWidth = parseInt(window.getComputedStyle(chart).width);
        startHeight = parseInt(window.getComputedStyle(chart).height);
        e.preventDefault();
      });

      document.addEventListener("mousemove", (e) => {
        if (isResizing) {
          const width = startWidth + (e.clientX - startX);
          const height = startHeight + (e.clientY - startY);
          chart.style.width = `${Math.max(300, Math.min(width, window.innerWidth * 0.9))}px`;
          chart.style.height = `${Math.max(200, Math.min(height, window.innerHeight * 0.9))}px`;
          if (cumulativeChart) cumulativeChart.resize();
        }
      });

      document.addEventListener("mouseup", () => {
        isResizing = false;
      });
    }

    function toggleMapVisibility() {
      const mapContainer = document.querySelector(".map-container");
      const chartContainer = document.querySelector(".chart-container");
      const contentWrapper = document.querySelector(".content-wrapper");
      const playBtnMobile = document.getElementById("playHistoryBtnMobile");
      const playBtnDesktop = document.getElementById("playHistoryBtnDesktop");
      const resetBtnMobile = document.getElementById("resetHistoryBtnMobile");
      const resetBtnDesktop = document.getElementById("resetHistoryBtnDesktop");
      const ssoHistory = document.getElementById("ssoHistory");

      mapVisible = !mapVisible;
      mapContainer.style.display = mapVisible ? "block" : "none";
      playBtnMobile.style.display = mapVisible ? "block" : "none";
      playBtnDesktop.style.display = mapVisible ? "block" : "none";
      resetBtnMobile.style.display = mapVisible ? "block" : "none";
      resetBtnDesktop.style.display = mapVisible ? "block" : "none";
      ssoHistory.style.display = mapVisible && isPlaying ? "block" : "none";
      document.getElementById("toggleMapBtn").textContent = mapVisible ? "Hide Map" : "Show Map";

      if (window.innerWidth <= 768) {
        chartContainer.style.height = mapVisible ? "50vh" : "calc(100vh - 9rem)";
        mapContainer.style.height = mapVisible ? "50vh" : "0";
        contentWrapper.style.flexDirection = "column";
      } else {
        contentWrapper.style.flexDirection = mapVisible ? "row" : "column";
        chartContainer.style.height = mapVisible ? "100%" : "calc(100% - 1rem)";
        mapContainer.style.height = mapVisible ? "100%" : "0";
      }
      if (myChart) myChart.resize();
      if (mapVisible && mapView) setTimeout(() => mapView.resize(), 100);
    }

    function toggleSidebar() {
      const mobileSidebar = document.getElementById("mobile-sidebar");
      const desktopSidebar = document.getElementById("desktop-sidebar");
      if (window.innerWidth <= 768) {
        mobileSidebar.style.display = "block";
        desktopSidebar.style.display = "none";
      } else {
        mobileSidebar.style.display = "none";
        desktopSidebar.style.display = "block";
      }
    }

    function showEventsDialog() {
      const dialog = document.getElementById("eventsDialog");
      const eventList = document.getElementById("eventList");
      eventList.innerHTML = "";
      const sortedEvents = [...specialWeatherEvents].sort((a, b) => b.date - a.date);
      sortedEvents.forEach(event => {
        const li = document.createElement("li");
        li.className = "event-item";
        li.innerHTML = `<span><span class="emoji">${event.emoji}</span><span class="date">${formatDateForDisplay(event.date)}</span></span><span class="description">${event.event}</span>`;
        eventList.appendChild(li);
      });
      dialog.style.display = "flex";
      dialog.addEventListener("click", handleOutsideClick);
    }

    function closeEventsDialog() {
      const dialog = document.getElementById("eventsDialog");
      dialog.style.display = "none";
      dialog.removeEventListener("click", handleOutsideClick);
    }

    function handleOutsideClick(event) {
      const dialog = document.getElementById("eventsDialog");
      const dialogBox = document.querySelector(".dialog-box");
      if (event.target === dialog && !dialogBox.contains(event.target)) closeEventsDialog();
    }

    function downloadCSV(data, filename) {
      const csvContent = "data:text/csv;charset=utf-8," + data;
      const encodedUri = encodeURI(csvContent);
      const link = document.createElement("a");
      link.setAttribute("href", encodedUri);
      link.setAttribute("download", filename);
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    function downloadChartData() {
      const aggDrought = aggregateData(rawDroughtData, currentPeriod);
      const aggSSO = aggregateSSOData(rawSSOFeatures, currentPeriod);
      let droughtCSV = "Date,Exceptional (D4),Extreme (D3),Severe (D2),Moderate (D1),Abnormally Dry (D0),No Drought\n";
      aggDrought.forEach(row => droughtCSV += `${formatDateForDisplay(row.date)},${row.d4},${row.d3},${row.d2},${row.d1},${row.d0},${row.none}\n`);
      let ssoCSV = "Date,SSO Count\n";
      aggSSO.forEach(row => ssoCSV += `${formatDateForDisplay(row.date)},${row.count}\n`);
      downloadCSV(droughtCSV, `drought_data_${currentPeriod}_${formatDateForDisplay(new Date())}.csv`);
      downloadCSV(ssoCSV, `sso_data_${currentPeriod}_${formatDateForDisplay(new Date())}.csv`);
    }

    function getMonthlyDates(startDate, endDate) {
      const dates = [];
      let current = new Date(startDate);
      while (current <= endDate) {
        dates.push(new Date(current));
        current.setMonth(current.getMonth() + 1);
      }
      return dates;
    }

function initializeDateSlider() {
  const minDate = new Date("2019-01-01");
  const maxDate = new Date("2025-03-16"); // Today
  const defaultStart = new Date("2019-01-01");
 const defaultEnd = new Date();

  const slider = document.getElementById("dateSlider");
  const track = document.getElementById("dateSliderTrack");
  const minHandle = document.getElementById("dateSliderMin");
  const maxHandle = document.getElementById("dateSliderMax");
  const label = document.getElementById("dateRangeLabel");

  const totalTime = maxDate - minDate;
  const startPos = ((defaultStart - minDate) / totalTime) * 100;
  const endPos = ((defaultEnd - minDate) / totalTime) * 100;

  minHandle.style.left = `${startPos}%`;
  maxHandle.style.left = `${endPos}%`;
  track.style.left = `${startPos}%`;
  track.style.width = `${endPos - startPos}%`;

  label.textContent = `${formatMonthForDisplay(defaultStart)} - ${formatMonthForDisplay(defaultEnd)}`;
  selectedDateRange = { start: defaultStart, end: defaultEnd };

  let activeHandle = null;

  function updateSliderPosition(handle, clientX) {
    const rect = slider.getBoundingClientRect();
    let percentage = (clientX - rect.left) / rect.width;
    percentage = Math.max(0, Math.min(1, percentage));

    if (handle === minHandle) {
      const maxPos = parseFloat(maxHandle.style.left) / 100;
      percentage = Math.min(percentage, maxPos - 0.01); // Prevent overlap
      minHandle.style.left = `${percentage * 100}%`;
      track.style.left = `${percentage * 100}%`;
      track.style.width = `${(maxPos - percentage) * 100}%`;
    } else {
      const minPos = parseFloat(minHandle.style.left) / 100;
      percentage = Math.max(percentage, minPos + 0.01); // Prevent overlap
      maxHandle.style.left = `${percentage * 100}%`;
      track.style.width = `${(percentage - minPos) * 100}%`;
    }

    const newStart = new Date(minDate.getTime() + (parseFloat(minHandle.style.left) / 100) * totalTime);
    const newEnd = new Date(minDate.getTime() + (parseFloat(maxHandle.style.left) / 100) * totalTime);
    selectedDateRange = { start: newStart, end: newEnd };
    label.textContent = `${formatMonthForDisplay(newStart)} - ${formatMonthForDisplay(newEnd)}`;
  }

  function startDragging(e) {
    activeHandle = e.target;
    activeHandle.classList.add("active");
    e.preventDefault();
  }

  function stopDragging() {
    if (activeHandle) {
      activeHandle.classList.remove("active");
      updateChartWithCurrentPeriod();
      updateMap();
      if (isPlaying) resetHistoryAnimation(); // Reset animation if playing
      activeHandle = null;
    }
  }

  function moveHandle(e) {
    if (activeHandle) {
      updateSliderPosition(activeHandle, e.clientX);
    }
  }

  minHandle.addEventListener("mousedown", startDragging);
  maxHandle.addEventListener("mousedown", startDragging);
  document.addEventListener("mousemove", moveHandle);
  document.addEventListener("mouseup", stopDragging);

  // Touch support for mobile
  minHandle.addEventListener("touchstart", (e) => startDragging(e.touches[0]));
  maxHandle.addEventListener("touchstart", (e) => startDragging(e.touches[0]));
  document.addEventListener("touchmove", (e) => moveHandle(e.touches[0]));
  document.addEventListener("touchend", stopDragging);
}

    document.addEventListener("DOMContentLoaded", () => {
      toggleSidebar();
      showLoading();
      Promise.all([fetchDroughtData(), fetchSSOData()])
        .then(([droughtFeatures, ssoFeatures]) => {
          rawDroughtData = droughtFeatures;
          rawSSOFeatures = ssoFeatures;
          createStructureTypeSwitch("#mobile-sidebar");
          createStructureTypeSwitch("#desktop-sidebar");
          createCauseCheckboxes("causeCheckboxes");
          createCauseCheckboxes("causeCheckboxesDesktop");

          const aggDrought = aggregateData(rawDroughtData, 'monthly');
          const aggSSO = aggregateSSOData(rawSSOFeatures, 'monthly');

          const ctx = document.getElementById("droughtChart").getContext("2d");
          myChart = new Chart(ctx, {
            type: "line",
            data: {
              datasets: [
                { label: "Exceptional", data: aggDrought.map(r => ({ x: r.date, y: r.d4 })), borderColor: "#4F0012", backgroundColor: "rgba(79, 0, 18, 0.7)", fill: "origin", tension: 0.1, pointRadius: 0, order: 1 },
                { label: "Extreme", data: aggDrought.map(r => ({ x: r.date, y: r.d3 })), borderColor: "#9C0924", backgroundColor: "rgba(156, 9, 36, 0.7)", fill: "-1", tension: 0.1, pointRadius: 0, order: 1 },
                { label: "Severe", data: aggDrought.map(r => ({ x: r.date, y: r.d2 })), borderColor: "#EC692D", backgroundColor: "rgba(236, 105, 45, 0.7)", fill: "-1", tension: 0.1, pointRadius: 0, order: 1 },
                { label: "Moderate", data: aggDrought.map(r => ({ x: r.date, y: r.d1 })), borderColor: "#F09D33", backgroundColor: "rgba(240, 157, 51, 0.7)", fill: "-1", tension: 0.1, pointRadius: 0, order: 1 },
                { label: "Abn. Dry", data: aggDrought.map(r => ({ x: r.date, y: r.d0 })), borderColor: "#FDEFA4", backgroundColor: "rgba(253, 239, 164, 0.7)", fill: "-1", tension: 0.1, pointRadius: 0, order: 1 },
                { label: "SSO Count", data: aggSSO.map(r => ({ x: r.date, y: r.count })), borderColor: "#00FF00", backgroundColor: "rgba(0, 255, 0, 0.7)", fill: false, tension: 0, pointRadius: 3, yAxisID: "y2", order: 0 },
                { label: "Special Weather Events", data: specialWeatherEvents.map(event => ({ x: event.date, y: 100, event: event.event, date: event.date.toISOString().split('T')[0] })), type: "scatter", yAxisID: "y", pointRadius: 0, pointHoverRadius: 50, showLine: false, order: -1, tooltip: { callbacks: { label: ctx => `${ctx.raw.date} | ${ctx.raw.event}` } } }
              ]
            },
            options: {
              responsive: true, maintainAspectRatio: false, interaction: { mode: "index", intersect: false },
              scales: { x: { type: "time", time: { unit: "month", tooltipFormat: "yyyy-MM-dd" }, ticks: { color: "#00d4ff" }, grid: { color: "rgba(0, 212, 255, 0.2)" } }, y: { stacked: true, min: 0, suggestedMax: 110, ticks: { color: "#00d4ff" }, grid: { color: "rgba(0, 212, 255, 0.2)" } }, y2: { type: "linear", position: "right", ticks: { color: "#00ff00" }, grid: { drawOnChartArea: false } } },
              plugins: {
                legend: { labels: { color: "#00d4ff", font: { family: 'Orbitron' } }, position: "top" },
                title: { display: true, text: "Drought & Public Sewer Overflow (Monthly)", color: "#00d4ff", font: { size: 16, family: 'Orbitron' } },
                zoom: { zoom: { wheel: { enabled: true }, drag: { enabled: true }, mode: "x" }, pan: { enabled: true, mode: "x" } },
                annotation: {
                  annotations: [
                    ...specialWeatherEvents.map((e, i) => ({ type: 'label', xValue: e.date, yValue: 100, content: e.emoji, color: '#ffffff', font: { size: 20 }, position: 'center', xAdjust: 0, yAdjust: -5, backgroundColor: 'rgba(0, 0, 0, 0)', borderWidth: 0 })),
                    { type: 'line', id: 'cursorLine', mode: 'vertical', scaleID: 'x', value: aggSSO[aggSSO.length - 1].date, borderColor: '#00d4ff', borderWidth: 2, label: { enabled: true, content: 'Latest', position: 'top', backgroundColor: 'rgba(0, 212, 255, 0.8)', font: { size: 12, family: 'Orbitron' } } }
                  ]
                },
                tooltip: { mode: "index", intersect: false, backgroundColor: 'rgba(10, 10, 30, 0.9)', titleFont: { family: 'Orbitron' }, bodyFont: { family: 'Orbitron' }, callbacks: { label: ctx => ctx.dataset.label === "Special Weather Events" ? `${ctx.raw.date} | ${ctx.raw.event}` : `${ctx.dataset.label}: ${ctx.raw.y}` } }
              }
            }
          });

          initializeCumulativeChart();
          makeChartDraggable();
          makeChartResizable();
          document.getElementById("closeCumulativeChart").addEventListener("click", () => {
            document.getElementById("cumulativeChartContainer").style.display = "none";
            if (isPlaying) resetHistoryAnimation();
          });

          initializeDateSlider();
          return initializeMap();
        })
        .then(() => {
          hideLoading();
          document.getElementById("toggleMapBtn").addEventListener("click", toggleMapVisibility);
          document.getElementById("weeklyBtn").addEventListener("click", () => { currentPeriod = 'weekly'; updateChartWithCurrentPeriod(); updateMap(); });
          document.getElementById("monthlyBtn").addEventListener("click", () => { currentPeriod = 'monthly'; updateChartWithCurrentPeriod(); updateMap(); });
          document.getElementById("yearlyBtn").addEventListener("click", () => { currentPeriod = 'yearly'; updateChartWithCurrentPeriod(); updateMap(); });
          document.getElementById("resetZoomBtn").addEventListener("click", () => {
            if (myChart) myChart.resetZoom();
            if (mapView) mapView.goTo({ center: [-95.3632715, 29.7632836], zoom: 10 });
            updateMap();
          });
          document.getElementById("showEventsBtn").addEventListener("click", showEventsDialog);
          document.getElementById("closeEventsDialog").addEventListener("click", closeEventsDialog);
          document.getElementById("playHistoryBtnMobile").addEventListener("click", toggleHistoryAnimation);
          document.getElementById("playHistoryBtnDesktop").addEventListener("click", toggleHistoryAnimation);
          document.getElementById("resetHistoryBtnMobile").addEventListener("click", resetHistoryAnimation);
          document.getElementById("resetHistoryBtnDesktop").addEventListener("click", resetHistoryAnimation);
          document.getElementById("downloadBtn").addEventListener("click", downloadChartData); // Download button event listener
          document.getElementById("playHistoryBtnMobile").style.display = mapVisible ? "block" : "none";
          document.getElementById("playHistoryBtnDesktop").style.display = mapVisible ? "block" : "none";
          document.getElementById("resetHistoryBtnMobile").style.display = "none";
          document.getElementById("resetHistoryBtnDesktop").style.display = "none";
          document.getElementById("downloadBtn").style.display = "inline-flex"; // Explicitly ensure visibility
        })
        .catch(error => {
          console.error("Error initializing:", error);
          hideLoading();
          alert("Failed to load data. Please try refreshing the page.");
        });
    });

    window.addEventListener('resize', () => {
      toggleSidebar();
      const chartContainer = document.querySelector(".chart-container");
      const mapContainer = document.querySelector(".map-container");
      const contentWrapper = document.querySelector(".content-wrapper");
      const playBtnMobile = document.getElementById("playHistoryBtnMobile");
      const playBtnDesktop = document.getElementById("playHistoryBtnDesktop");
      const resetBtnMobile = document.getElementById("resetHistoryBtnMobile");
      const resetBtnDesktop = document.getElementById("resetHistoryBtnDesktop");
      const ssoHistory = document.getElementById("ssoHistory");

      if (window.innerWidth <= 768) {
        chartContainer.style.height = mapVisible ? "50vh" : "calc(100vh - 9rem)";
        contentWrapper.style.flexDirection = "column";
        mapContainer.style.height = mapVisible ? "50vh" : "0";
      } else {
        contentWrapper.style.flexDirection = mapVisible ? "row" : "column";
        chartContainer.style.height = mapVisible ? "100%" : "calc(100% - 1rem)";
        mapContainer.style.height = mapVisible ? "100%" : "0";
      }
      playBtnMobile.style.display = mapVisible ? "block" : "none";
      playBtnDesktop.style.display = mapVisible ? "block" : "none";
      resetBtnMobile.style.display = mapVisible ? "block" : "none";
      resetBtnDesktop.style.display = mapVisible ? "block" : "none";
      ssoHistory.style.display = mapVisible && isPlaying ? "block" : "none";
      if (myChart) myChart.resize();
    });
  </script>
</body>
</html>
