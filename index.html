<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>COH - Drought & Sewer Overflow Awareness</title>
  <!-- Chart.js + date adapter + zoom plugin via CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@latest"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2"></script>
  <!-- ArcGIS JS API -->
  <link rel="stylesheet" href="https://js.arcgis.com/4.29/esri/themes/dark/main.css">
  <script src="https://js.arcgis.com/4.29/"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: linear-gradient(145deg, #0d0d1a, #1a1a33);
      color: #e0e0e0;
      font-family: 'Orbitron', 'Segoe UI', sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      overflow-x: hidden;
      background-image: radial-gradient(circle at 50% 50%, rgba(0, 212, 255, 0.1) 0%, transparent 70%);
    }
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

    .container {
      display: flex;
      flex-direction: column;
      width: 100%;
      min-height: 100vh;
      background: rgba(20, 20, 40, 0.8);
      box-shadow: inset 0 0 20px rgba(0, 212, 255, 0.1);
    }
    .sidebar {
      width: 100%;
      padding: 0.8rem;
      background: linear-gradient(180deg, rgba(20, 20, 40, 0.95), rgba(10, 10, 30, 0.95));
      border-bottom: 1px solid rgba(0, 212, 255, 0.4);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(10px);
    }
    .sidebar summary {
      cursor: pointer;
      font-size: 1.1rem;
      color: #00d4ff;
      text-shadow: 0 0 8px #00d4ff;
      padding: 0.5rem 0;
      border-bottom: 1px solid rgba(0, 212, 255, 0.3);
      margin-bottom: 0.5rem;
      transition: all 0.2s ease;
    }
    .sidebar summary:hover {
      text-shadow: 0 0 12px #00d4ff;
    }
    .sidebar h3 {
      font-size: 1rem;
      margin: 0.5rem 0;
      color: #00d4ff;
      text-shadow: 0 0 6px #00d4ff;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .main-content {
      flex: 1;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: linear-gradient(180deg, rgba(20, 20, 40, 0.7), rgba(10, 10, 30, 0.7));
      min-height: 0;
    }
    .content-wrapper {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
      flex-grow: 1;
      min-height: 0;
    }
    .chart-container, .map-container {
      width: 100%;
      background: rgba(10, 10, 30, 0.9);
      border-radius: 8px;
      box-shadow: 0 4px 15px rgba(0, 212, 255, 0.2), inset 0 0 10px rgba(0, 212, 255, 0.1);
      padding: 0.8rem;
      overflow: hidden;
      height: 50vh;
      border: 1px solid rgba(0, 212, 255, 0.3);
    }
    canvas, #map {
      width: 100% !important;
      height: 100% !important;
      border-radius: 4px;
      box-shadow: inset 0 0 8px rgba(0, 212, 255, 0.2);
    }
    button {
      padding: 0.5rem 0.8rem;
      font-size: 0.85rem;
      cursor: pointer;
      margin: 0.2rem;
      background: linear-gradient(45deg, #00d4ff, #007bff);
      color: #fff;
      border: none;
      border-radius: 4px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: 0 2px 8px rgba(0, 212, 255, 0.4);
      transition: all 0.2s ease;
      min-width: 70px;
      font-family: 'Orbitron', sans-serif;
    }
    button:hover {
      transform: translateY(-1px) scale(1.03);
      box-shadow: 0 4px 12px rgba(0, 212, 255, 0.6);
      background: linear-gradient(45deg, #00eaff, #008cff);
    }
    button.selected {
      background: linear-gradient(45deg, #ff00cc, #ff6699);
      box-shadow: 0 4px 12px rgba(255, 0, 204, 0.6);
    }
    button.selected:hover {
      background: linear-gradient(45deg, #ff33dd, #ff88aa);
    }
    .checkbox-group {
      margin-bottom: 0.5rem;
    }
    .checkbox-group summary {
      cursor: pointer;
      font-weight: 600;
      font-size: 0.85rem;
      padding: 0.4rem;
      background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(0, 123, 255, 0.05));
      border-radius: 4px;
      display: flex;
      align-items: center;
      transition: all 0.2s ease;
      color: #00d4ff;
      text-shadow: 0 0 4px rgba(0, 212, 255, 0.5);
    }
    .checkbox-group summary:hover {
      background: linear-gradient(135deg, rgba(0, 212, 255, 0.15), rgba(0, 123, 255, 0.08));
      text-shadow: 0 0 8px rgba(0, 212, 255, 0.7);
    }
    .checkbox-group summary::after {
      content: '▼';
      font-size: 0.7rem;
      margin-left: 0.4rem;
      transition: transform 0.2s ease;
    }
    .checkbox-group[open] summary::after {
      transform: rotate(180deg);
    }
    .checkbox-group input[type="checkbox"] {
      -webkit-appearance: none;
      appearance: none;
      width: 0.9rem;
      height: 0.9rem;
      margin-right: 0.4rem;
      position: relative;
      cursor: pointer;
      background: linear-gradient(135deg, #1a1a33, #0d0d1a);
      border: 1px solid #00d4ff;
      border-radius: 2px;
      transition: all 0.2s ease;
      box-shadow: 0 0 4px rgba(0, 212, 255, 0.3);
    }
    .checkbox-group input[type="checkbox"]:checked {
      background: linear-gradient(135deg, #00d4ff, #007bff);
      box-shadow: 0 0 6px rgba(0, 212, 255, 0.6);
    }
    .checkbox-group input[type="checkbox"]:checked::after {
      content: "✔";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.6rem;
      color: #fff;
      text-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
    }
    .checkbox-group label {
      display: flex;
      align-items: center;
      padding: 0.3rem 0.4rem;
      background: rgba(0, 212, 255, 0.05);
      transition: all 0.2s ease;
      font-size: 0.8rem;
      border-radius: 2px;
    }
    .checkbox-group details label {
      padding-left: 1.2rem;
    }
    .checkbox-group label:hover {
      background: rgba(0, 212, 255, 0.1);
      color: #fff;
    }
    h1 {
      font-size: 1.4rem;
      color: #00d4ff;
      text-shadow: 0 0 10px #00d4ff, 0 0 20px rgba(0, 212, 255, 0.5);
      margin-bottom: 0.5rem;
      text-align: center;
      font-weight: 700;
      letter-spacing: 1.5px;
    }
    p {
      font-size: 0.75rem;
      color: #b0b0b0;
      margin-bottom: 0.8rem;
      text-align: center;
      text-shadow: 0 0 4px rgba(0, 212, 255, 0.3);
    }
    .switch-container {
      margin-bottom: 0.5rem;
      text-align: center;
      width: 100%;
    }
    .structure-buttons {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 100%;
    }
    .structure-btn {
      flex: 1;
      padding: 0.1rem;
      font-size: 0.75rem;
      background: linear-gradient(45deg, #1a1a33, #0d0d1a);
      border: 1px solid #00d4ff;
      border-radius: 4px;
      color: #e0e0e0;
      cursor: pointer;
      text-transform: uppercase;
      transition: all 0.2s ease;
      box-shadow: 0 0 4px rgba(0, 212, 255, 0.3);
    }
    .structure-btn:hover {
      color: #fff;
      box-shadow: 0 2px 8px rgba(0, 212, 255, 0.6);
      background: linear-gradient(45deg, #2a2a4d, #1a1a33);
    }
    .structure-btn.active {
      background: linear-gradient(45deg, #00d4ff, #007bff);
      color: #fff;
      box-shadow: 0 2px 10px rgba(0, 212, 255, 0.7);
    }
    .footer {
      width: 100%;
      text-align: center;
      padding: 0.5rem;
      font-size: 0.65rem;
      font-weight: bold;
      color: #00d4ff;
      text-shadow: 0 0 6px #00d4ff;
      background: none;
    }
    .footer span {
      color: #ff3366;
      font-size: 0.85rem;
      text-shadow: 0 0 6px #ff3366;
    }

    /* Loading Overlay */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 10, 30, 0.9);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      backdrop-filter: blur(5px);
    }
    .loading-text {
      font-size: 2rem;
      color: #00d4ff;
      text-shadow: 0 0 10px #00d4ff, 0 0 20px rgba(0, 212, 255, 0.5);
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      letter-spacing: 2px;
      animation: pulse 1.5s infinite ease-in-out;
      position: relative;
    }
    .loading-text::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 150%;
      height: 150%;
      background: radial-gradient(circle, rgba(0, 212, 255, 0.2) 0%, transparent 70%);
      transform: translate(-50%, -50%);
      animation: glow 2s infinite ease-in-out;
      z-index: -1;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.05); opacity: 0.8; }
    }
    @keyframes glow {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 0.5; }
    }

    /* Desktop Styles */
    @media (min-width: 769px) {
      .container {
        flex-direction: row;
      }
      .sidebar {
        width: 250px;
        height: 100vh;
        border-bottom: none;
        border-right: 1px solid rgba(0, 212, 255, 0.4);
        position: fixed;
        top: 0;
        left: 0;
        overflow-y: auto;
        background: linear-gradient(180deg, rgba(20, 20, 40, 0.98), rgba(10, 10, 30, 0.98));
        box-shadow: 2px 0 15px rgba(0, 0, 0, 0.6);
      }
      .sidebar-content {
        display: block;
      }
      .sidebar h3 {
        font-size: 1.1rem;
        margin: 0.6rem 0 0.4rem;
      }
      .main-content {
        flex: 1;
        margin-left: 250px;
        overflow-y: hidden;
        height: 100vh;
        padding: 0.8rem;
      }
      .content-wrapper {
        flex-direction: row;
        height: calc(100% - 5rem); /* Adjusted for header + buttons + footer */
        margin: 0;
      }
      .chart-container, .map-container {
        flex: 1;
        height: 100%;
        max-height: 100%;
      }
      button {
        padding: 0.6rem 1rem;
        font-size: 0.9rem;
      }
      h1 {
        font-size: 1.6rem;
      }
      p {
        font-size: 0.85rem;
      }
      .structure-btn {
        padding: 0.5rem;
        font-size: 0.8rem;
      }
      .checkbox-group summary {
        font-size: 0.9rem;
        padding: 0.5rem;
      }
      .checkbox-group input[type="checkbox"] {
        width: 1rem;
        height: 1rem;
      }
      .checkbox-group label {
        padding: 0.4rem 0.5rem;
        font-size: 0.85rem;
      }
      .loading-text {
        font-size: 2.5rem;
      }
    }
  </style>
</head>
<body>
  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-text">Initializing Data...</div>
  </div>

  <div class="container">
    <!-- Mobile Sidebar with <details> -->
    <details class="sidebar" id="mobile-sidebar">
      <summary>Filter</summary>
      <div class="sidebar-content">
        <h3>SSO by Struct. Type</h3>
        <div class="switch-container">
          <div class="structure-buttons">
            <button class="structure-btn active" data-type="All" title="Show all SSO Structure types">All</button>
            <button class="structure-btn" data-type="Main" title="Show SSO from Main Sewer">Main</button>
            <button class="structure-btn" data-type="Lateral" title="Show SSO from Service Laterals">SLat</button>
          </div>
        </div>
        <h3>SSO by Cause</h3>
        <div id="causeCheckboxes"></div>
      </div>
    </details>
    <!-- Desktop Sidebar without <details> -->
    <div class="sidebar" id="desktop-sidebar" style="display: none;">
      <div class="sidebar-content">
        <h3>SSO by Struct. Type</h3>
        <div class="switch-container">
          <div class="structure-buttons">
            <button class="structure-btn active" data-type="All" title="Show all SSO Structure types">All</button>
            <button class="structure-btn" data-type="Main" title="Show SSO from Main Sewer">Main</button>
            <button class="structure-btn" data-type="Lateral" title="Show SSO from Service Laterals">SLat</button>
          </div>
        </div>
        <h3>SSO by Cause</h3>
        <div id="causeCheckboxesDesktop"></div>
      </div>
    </div>
    <div class="main-content">
      <h1>COH - Drought & Sewer Overflow Awareness</h1>
      <p>Tap chart to update map date; Zoom/pan chart or map, then tap <em>Reset Zoom</em></p>
      <div>
        <button id="weeklyBtn">Weekly</button>
        <button id="monthlyBtn" class="selected">Monthly</button>
        <button id="yearlyBtn">Yearly</button>
        <button id="resetZoomBtn">Reset Zoom</button>
        <button id="toggleMapBtn">Hide Map</button>
      </div>
      <div class="content-wrapper">
        <div class="chart-container">
          <canvas id="droughtChart"></canvas>
        </div>
        <div class="map-container">
          <div id="map"></div>
        </div>
      </div>
      <div class="footer">
        Made with <span>❤</span> by WWO - HNg - 2025 - Disclaimer: Data provided 'as is' for informational use only.
      </div>
    </div>
  </div>

  <script>
    const droughtApiUrl = "https://services9.arcgis.com/RHVPKKiFTONKtxq3/ArcGIS/rest/services/US_Drought_Intensity_v1/FeatureServer/1/query" +
      "?where=admin_fips%3D48201" +
      "&outFields=*" +
      "&f=json";
    const ssoApiUrl = "https://services.arcgis.com/NummVBqZSIJKUeVR/arcgis/rest/services/RSSO_Package/FeatureServer/0/query";

    let rawDroughtData = [];
    let rawSSOFeatures = [];
    let myChart, mapView;
    let uniqueCauses = [];
    let selectedCauses = new Set();
    let selectedStructureGroup = "All";
    let currentPeriod = 'monthly';
    let selectedDate = null;
    let mapVisible = true;

    const sewerMainTypes = ["Manhole", "Lift Station", "Gravity Main", "Force Main", "Treatment Plant"];

    const specialWeatherEvents = [
      { event: "Tropical Storm Imelda", date: new Date("2019-09-19"), emoji: "⛈️" },
      { event: "Hurricane Laura (Outer Bands)", date: new Date("2020-08-27"), emoji: "🌀" },
      { event: "Hurricane Beta (Outer Bands)", date: new Date("2020-09-21"), emoji: "🌀" },
      { event: "Winter Storm Uri", date: new Date("2021-02-15"), emoji: "❄️" },
      { event: "Hurricane Nicholas", date: new Date("2021-09-14"), emoji: "🌀" },
      { event: "Severe Thunderstorms and Tornadoes", date: new Date("2023-01-24"), emoji: "🌪️" },
      { event: "Extreme Heat and Drought", date: new Date("2023-08-01"), emoji: "☀️" },
      { event: "Hurricane Beryl", date: new Date("2024-07-08"), emoji: "🌀" },
      { event: "Derecho", date: new Date("2024-05-16"), emoji: "💨" },
      { event: "Winter Storm (Snow and Extreme Cold)", date: new Date("2025-01-20"), emoji: "❄️" }
    ];

    const structureGroups = {
      "All": { color: "#FFFFFF", outline: "#CCCCCC" },
      "Main": { color: "#00FF99", outline: "#00CC77" },
      "Service Lateral": { color: "#FF00CC", outline: "#CC0099" }
    };

    function showLoading() {
      document.getElementById("loadingOverlay").style.display = "flex";
    }

    function hideLoading() {
      document.getElementById("loadingOverlay").style.display = "none";
    }

    function fetchDroughtData() {
      return fetch(droughtApiUrl)
        .then(response => response.ok ? response.json() : Promise.reject("Drought data error: " + response.status))
        .then(json => {
          if (!json.features || json.features.length === 0) throw new Error("No drought features returned");
          return json.features
            .map(f => ({
              date: new Date(f.attributes.ddate),
              d4: f.attributes.d4 || 0,
              d3: f.attributes.d3 || 0,
              d2: f.attributes.d2 || 0,
              d1: f.attributes.d1 || 0,
              d0: f.attributes.d0 || 0,
              none: f.attributes.nothing || 0
            }))
            .filter(r => r.date >= new Date("2019-01-01"))
            .sort((a, b) => a.date - b.date);
        });
    }

    function fetchSSOData(resultOffset = 0, accumulated = []) {
      const queryParams = new URLSearchParams({
        where: "System LIKE '%ublic%' AND STARTDATE >= date '2019-01-01'",
        outFields: "*",
        f: "json",
        returnGeometry: true,
        resultOffset: resultOffset,
        resultRecordCount: 2000,
        orderByFields: "STARTDATE ASC"
      });

      return fetch(ssoApiUrl + "?" + queryParams.toString())
        .then(response => response.ok ? response.json() : Promise.reject("SSO data error: " + response.status))
        .then(json => {
          if (!json.features) return accumulated;
          accumulated.push(...json.features);
          if (json.exceededTransferLimit) return fetchSSOData(resultOffset + 2000, accumulated);
          return accumulated;
        });
    }

    function normalizeCause(cause) {
      return cause ? cause.toLowerCase().replace(/–/g, "-").replace(/\s+/g, " ").trim() : "Unknown";
    }

    function groupCauses(causes) {
      const grouped = {
        "Grease": [], "Rags/Wipes": [], "Roots": [], "Structural Issues": [], "Blockages": [],
        "Wet Weather": [], "Lift Station/Treatment Plant/Power": [], "Cross Connections": [],
        "Other": [], "Unknown": []
      };

      causes.forEach(cause => {
        const normalized = normalizeCause(cause);
        const original = cause || "Unknown";
        if (normalized.includes("grease blockage")) grouped["Grease"].push(original);
        else if (normalized.includes("rags/wipes")) grouped["Rags/Wipes"].push(original);
        else if (normalized.includes("roots")) grouped["Roots"].push(original);
        else if (normalized.includes("pump/lift station") || normalized.includes("wwtp") || normalized.includes("power outage")) grouped["Lift Station/Treatment Plant/Power"].push(original);
        else if (normalized.includes("structural failure") || normalized.includes("structural blockage")) grouped["Structural Issues"].push(original);
        else if (normalized.includes("temporary blockage")) grouped["Blockages"].push(original);
        else if (normalized.includes("wet weather")) grouped["Wet Weather"].push(original);
        else if (normalized.includes("cross connection") || normalized.includes("cross-connection")) grouped["Cross Connections"].push(original);
        else if (normalized === "unknown") grouped["Unknown"].push(original);
        else grouped["Other"].push(original);
      });

      for (const group in grouped) grouped[group].sort();
      return grouped;
    }

    function createStructureTypeSwitch(containerSelector) {
      const buttons = document.querySelectorAll(`${containerSelector} .structure-btn`);
      if (buttons.length === 0) {
        console.error(`No structure buttons found in ${containerSelector}`);
        return;
      }
      buttons.forEach(button => {
        button.addEventListener('click', () => {
          buttons.forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');
          selectedStructureGroup = button.getAttribute('data-type') === "All" ? "All" :
                                   button.getAttribute('data-type') === "Main" ? "Main" : "Service Lateral";
          updateChartWithCurrentPeriod();
          updateMap();
        });
      });
      console.log(`Structure type switch initialized for ${containerSelector}`);
    }

    function createCauseCheckboxes(containerId) {
      if (!rawSSOFeatures || rawSSOFeatures.length === 0) {
        console.error("No SSO features available to create checkboxes");
        document.getElementById(containerId).innerHTML = "<p>No data available</p>";
        return;
      }
      uniqueCauses = [...new Set(rawSSOFeatures.map(f => f.attributes.CAUSE))];
      const groupedCauses = groupCauses(uniqueCauses);
      const container = document.getElementById(containerId);
      if (!container) {
        console.error(`Container ${containerId} not found`);
        return;
      }
      container.innerHTML = ""; // Clear existing content

      const allCheckbox = document.createElement("div");
      allCheckbox.className = "checkbox-group";
      allCheckbox.innerHTML = `<label><input type="checkbox" id="cause-all-${containerId}" checked> All</label>`;
      container.appendChild(allCheckbox);

      const categoryOrder = ["Grease", "Rags/Wipes", "Roots", "Structural Issues", "Blockages",
                            "Wet Weather", "Lift Station/Treatment Plant/Power", "Cross Connections",
                            "Other", "Unknown"];

      categoryOrder.forEach(category => {
        const causes = groupedCauses[category];
        if (causes.length === 0) return;
        const details = document.createElement("details");
        details.className = "checkbox-group";
        details.innerHTML = `<summary><input type="checkbox" class="category-checkbox" data-category="${category}" checked> ${category}</summary>`;
        causes.forEach(cause => {
          details.innerHTML += `<label><input type="checkbox" class="cause-checkbox" data-cause="${cause || 'Unknown'}" checked> ${cause || 'Unknown'}</label>`;
          selectedCauses.add(cause || 'Unknown');
        });

        const categoryCheckbox = details.querySelector(".category-checkbox");
        categoryCheckbox.addEventListener("change", (e) => {
          const isChecked = e.target.checked;
          details.querySelectorAll(".cause-checkbox").forEach(cb => {
            cb.checked = isChecked;
            const cause = cb.getAttribute("data-cause");
            isChecked ? selectedCauses.add(cause) : selectedCauses.delete(cause);
          });
          updateAllCheckbox();
          updateChartWithCurrentPeriod();
          updateMap();
        });

        details.querySelectorAll(".cause-checkbox").forEach(cb => {
          cb.addEventListener("change", (e) => {
            const cause = e.target.getAttribute("data-cause");
            e.target.checked ? selectedCauses.add(cause) : selectedCauses.delete(cause);
            const allChecked = [...details.querySelectorAll(".cause-checkbox")].every(c => c.checked);
            categoryCheckbox.checked = allChecked;
            updateAllCheckbox();
            updateChartWithCurrentPeriod();
            updateMap();
          });
        });

        container.appendChild(details);
      });

      document.getElementById(`cause-all-${containerId}`).addEventListener("change", (e) => {
        const isChecked = e.target.checked;
        container.querySelectorAll(".cause-checkbox, .category-checkbox").forEach(cb => {
          cb.checked = isChecked;
          if (cb.classList.contains("cause-checkbox")) {
            const cause = cb.getAttribute("data-cause");
            isChecked ? selectedCauses.add(cause) : selectedCauses.delete(cause);
          }
        });
        updateChartWithCurrentPeriod();
        updateMap();
      });

      function updateAllCheckbox() {
        const allCheckbox = document.getElementById(`cause-all-${containerId}`);
        if (allCheckbox) {
          allCheckbox.checked = categoryOrder.every(cat => {
            const catCheckbox = container.querySelector(`[data-category="${cat}"]`);
            return !catCheckbox || catCheckbox.checked;
          });
        }
      }
      console.log(`Cause checkboxes created for ${containerId} with ${uniqueCauses.length} unique causes`);
    }

    function aggregateData(data, period) {
      if (period === 'weekly') return data;
      const groups = {};
      data.forEach(record => {
        const date = new Date(record.date);
        const key = period === 'monthly' ? `${date.getFullYear()}-${date.getMonth() + 1}` : `${date.getFullYear()}`;
        groups[key] = groups[key] || [];
        groups[key].push(record);
      });
      return Object.entries(groups).map(([key, group]) => {
        const sum = group.reduce((acc, cur) => ({
          d4: acc.d4 + cur.d4, d3: acc.d3 + cur.d3, d2: acc.d2 + cur.d2,
          d1: acc.d1 + cur.d1, d0: acc.d0 + cur.d0, none: acc.none + cur.none
        }), { d4: 0, d3: 0, d2: 0, d1: 0, d0: 0, none: 0 });
        const count = group.length;
        return {
          date: group[0].date,
          d4: sum.d4 / count, d3: sum.d3 / count, d2: sum.d2 / count,
          d1: sum.d1 / count, d0: sum.d0 / count, none: sum.none / count
        };
      }).sort((a, b) => a.date - b.date);
    }

    function getWeekEndDate(date) {
      const d = new Date(date);
      d.setDate(d.getDate() + (6 - d.getDay()));
      return d;
    }

    function aggregateSSOData(features, period) {
      let filteredFeatures = features;
      if (selectedStructureGroup === "Main") filteredFeatures = features.filter(f => sewerMainTypes.includes(f.attributes.STRUCTURETYPE));
      else if (selectedStructureGroup === "Service Lateral") filteredFeatures = features.filter(f => !sewerMainTypes.includes(f.attributes.STRUCTURETYPE) || !f.attributes.STRUCTURETYPE);
      filteredFeatures = selectedCauses.size === 0 || selectedCauses.size === uniqueCauses.length ? filteredFeatures : filteredFeatures.filter(f => selectedCauses.has(f.attributes.CAUSE || 'Unknown'));

      const groups = {};
      filteredFeatures.forEach(f => {
        const eventDate = new Date(f.attributes.STARTDATE);
        let key, repDate;
        if (period === 'weekly') {
          const weekEnd = getWeekEndDate(eventDate);
          key = weekEnd.toISOString();
          repDate = weekEnd;
        } else if (period === 'monthly') {
          key = `${eventDate.getFullYear()}-${eventDate.getMonth() + 1}`;
          repDate = new Date(eventDate.getFullYear(), eventDate.getMonth(), 1);
        } else if (period === 'yearly') {
          key = `${eventDate.getFullYear()}`;
          repDate = new Date(eventDate.getFullYear(), 0, 1);
        }
        groups[key] = groups[key] || { date: repDate, count: 0 };
        groups[key].count += 1;
      });
      return Object.values(groups).sort((a, b) => a.date - b.date);
    }

    function formatDateForDisplay(date) {
      const d = new Date(date);
      return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
    }

    function getPeriodDateRange(date, period) {
      const startDate = new Date(date);
      const endDate = new Date(startDate);
      if (period === 'weekly') {
        endDate.setDate(startDate.getDate() + 6);
      } else if (period === 'monthly') {
        endDate.setMonth(startDate.getMonth() + 1, 0);
      } else if (period === 'yearly') {
        endDate.setFullYear(startDate.getFullYear() + 1, 11, 31);
      }
      return { start: startDate, end: endDate };
    }

    function updateChart(aggDrought, aggSSO) {
      myChart.data.datasets[0].data = aggDrought.map(r => ({ x: r.date, y: r.d4 }));
      myChart.data.datasets[1].data = aggDrought.map(r => ({ x: r.date, y: r.d3 }));
      myChart.data.datasets[2].data = aggDrought.map(r => ({ x: r.date, y: r.d2 }));
      myChart.data.datasets[3].data = aggDrought.map(r => ({ x: r.date, y: r.d1 }));
      myChart.data.datasets[4].data = aggDrought.map(r => ({ x: r.date, y: r.d0 }));
      myChart.data.datasets[5].data = aggSSO.map(r => ({ x: r.date, y: r.count }));
      myChart.options.plugins.title.text = `Drought & SSO (${currentPeriod.charAt(0).toUpperCase() + currentPeriod.slice(1)})`;
      myChart.options.plugins.annotation.annotations = [
        ...specialWeatherEvents.map((e, i) => ({
          type: 'label', xValue: e.date, yValue: 100, content: e.emoji, color: '#ffffff', font: { size: 20 }, position: 'center', xAdjust: 0, yAdjust: -5, backgroundColor: 'rgba(0, 0, 0, 0)', borderWidth: 0
        })),
        {
          type: 'line',
          id: 'cursorLine',
          mode: 'vertical',
          scaleID: 'x',
          value: selectedDate || aggSSO[aggSSO.length - 1].date,
          borderColor: '#00d4ff',
          borderWidth: 2,
          label: {
            enabled: true,
            content: selectedDate ? formatDateForDisplay(selectedDate) : 'Latest',
            position: 'top',
            backgroundColor: 'rgba(0, 212, 255, 0.8)',
            font: { size: 12 }
          }
        }
      ];
      myChart.update();
    }

    function updateChartWithCurrentPeriod() {
      const aggDrought = aggregateData(rawDroughtData, currentPeriod);
      const aggSSO = aggregateSSOData(rawSSOFeatures, currentPeriod);
      updateChart(aggDrought, aggSSO);
      document.querySelectorAll("#weeklyBtn, #monthlyBtn, #yearlyBtn").forEach(btn => btn.classList.remove("selected"));
      document.getElementById(`${currentPeriod}Btn`).classList.add("selected");
    }

    function initializeMap() {
      return new Promise((resolve, reject) => {
        require([
          "esri/Map",
          "esri/views/MapView",
          "esri/layers/FeatureLayer",
          "esri/widgets/Legend",
          "esri/widgets/Expand"
        ], (Map, MapView, FeatureLayer, Legend, Expand) => {
          try {
            const ssoLayer = new FeatureLayer({
              url: "https://services.arcgis.com/NummVBqZSIJKUeVR/arcgis/rest/services/RSSO_Package/FeatureServer/0",
              outFields: ["*"],
              definitionExpression: "System LIKE '%ublic%' AND STARTDATE >= '2019-01-01'",
              renderer: {
                type: "unique-value",
                valueExpression: `
                  var structureType = $feature.STRUCTURETYPE;
                  if (IsEmpty(structureType)) return 'Service Lateral';
                  if (Includes(['Manhole', 'Lift Station', 'Gravity Main', 'Force Main', 'Treatment Plant'], structureType)) return 'Main';
                  return 'Service Lateral';
                `,
                uniqueValueInfos: [
                  {
                    value: "Main",
                    symbol: {
                      type: "simple-marker",
                      color: structureGroups["Main"].color,
                      size: 8,
                      outline: { color: structureGroups["Main"].outline, width: 1.5 }
                    }
                  },
                  {
                    value: "Service Lateral",
                    symbol: {
                      type: "simple-marker",
                      color: structureGroups["Service Lateral"].color,
                      size: 8,
                      outline: { color: structureGroups["Service Lateral"].outline, width: 1.5 }
                    }
                  }
                ],
                defaultSymbol: { 
                  type: "simple-marker", 
                  color: structureGroups["All"].color, 
                  size: 8, 
                  outline: { color: structureGroups["All"].outline, width: 1.5 }
                }
              }
            });

            const map = new Map({
              basemap: "streets-night-vector",
              layers: [ssoLayer]
            });

            mapView = new MapView({
              container: "map",
              map: map,
              center: [-95.3632715, 29.7632836],
              zoom: 10
            });

            const legend = new Legend({
              view: mapView,
              layerInfos: [{ layer: ssoLayer, title: "SSO Events by Structure Type" }]
            });

            const legendExpand = new Expand({
              view: mapView,
              content: legend,
              expanded: false,
              expandTooltip: "Show Legend",
              collapseTooltip: "Hide Legend"
            });

            mapView.ui.add(legendExpand, "top-right");

            mapView.when(() => {
              console.log("Map initialized successfully");
              updateMap();
              resolve();
            }).catch(err => reject(err));
          } catch (error) {
            reject(error);
          }
        }, err => reject(err));
      });
    }

    function updateMap() {
      if (!mapView) return;
      require(["esri/layers/FeatureLayer"], (FeatureLayer) => {
        const ssoLayer = mapView.map.layers.find(layer => layer.url.includes("RSSO_Package"));
        if (!ssoLayer) return;
        let ssoWhereClause = "System LIKE '%ublic%' AND STARTDATE >= '2019-01-01'";
        
        if (selectedDate) {
          const { start, end } = getPeriodDateRange(selectedDate, currentPeriod);
          const startStr = formatDateForDisplay(start);
          const endStr = formatDateForDisplay(end);
          ssoWhereClause += ` AND STARTDATE >= '${startStr}' AND STARTDATE <= '${endStr}'`;
        } else {
          const aggSSO = aggregateSSOData(rawSSOFeatures, currentPeriod);
          const latestDate = aggSSO[aggSSO.length - 1].date;
          const { start, end } = getPeriodDateRange(latestDate, currentPeriod);
          const startStr = formatDateForDisplay(start);
          const endStr = formatDateForDisplay(end);
          ssoWhereClause += ` AND STARTDATE >= '${startStr}' AND STARTDATE <= '${endStr}'`;
        }

        if (selectedStructureGroup === "Main") {
          ssoWhereClause += ` AND STRUCTURETYPE IN ('${sewerMainTypes.join("','")}')`;
        } else if (selectedStructureGroup === "Service Lateral") {
          ssoWhereClause += ` AND (STRUCTURETYPE NOT IN ('${sewerMainTypes.join("','")}') OR STRUCTURETYPE IS NULL)`;
        }

        if (selectedCauses.size > 0 && selectedCauses.size < uniqueCauses.length) {
          const causesArray = Array.from(selectedCauses).map(c => c === "Unknown" ? "CAUSE IS NULL" : `CAUSE = '${c}'`);
          ssoWhereClause += ` AND (${causesArray.join(" OR ")})`;
        }

        ssoLayer.definitionExpression = ssoWhereClause;
      });
    }

	function toggleMapVisibility() {
	  const mapContainer = document.querySelector(".map-container");
	  const chartContainer = document.querySelector(".chart-container");
	  const contentWrapper = document.querySelector(".content-wrapper");

	  mapVisible = !mapVisible;
	  mapContainer.style.display = mapVisible ? "block" : "none";
	  document.getElementById("toggleMapBtn").textContent = mapVisible ? "Hide Map" : "Show Map";

	  if (window.innerWidth <= 768) {
		chartContainer.style.height = mapVisible ? "50vh" : "calc(100vh - 9rem)"; // Adjusted for mobile header + buttons + footer
		mapContainer.style.height = mapVisible ? "50vh" : "0"; // Explicitly set map height
		contentWrapper.style.flexDirection = "column";
	  } else {
		contentWrapper.style.flexDirection = mapVisible ? "row" : "column";
		chartContainer.style.height = mapVisible ? "100%" : "calc(100% - 1rem)"; // Leaves space for footer
		mapContainer.style.height = mapVisible ? "100%" : "0"; // Explicitly set map height
	  }

	  if (myChart) myChart.resize();
	  if (mapVisible && mapView) {
		setTimeout(() => {
		  mapView.resize(); // Resize map after a short delay
		}, 100); // 100ms delay to ensure DOM update
	  }
	}

    function toggleSidebar() {
      const mobileSidebar = document.getElementById("mobile-sidebar");
      const desktopSidebar = document.getElementById("desktop-sidebar");
      if (window.innerWidth <= 768) {
        mobileSidebar.style.display = "block";
        desktopSidebar.style.display = "none";
      } else {
        mobileSidebar.style.display = "none";
        desktopSidebar.style.display = "block";
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      toggleSidebar();
      showLoading(); // Show loading overlay at the start
      Promise.all([fetchDroughtData(), fetchSSOData()])
        .then(([droughtFeatures, ssoFeatures]) => {
          rawDroughtData = droughtFeatures;
          rawSSOFeatures = ssoFeatures;
          console.log("Data fetched: Drought features:", rawDroughtData.length, "SSO features:", rawSSOFeatures.length);

          createStructureTypeSwitch("#mobile-sidebar");
          createStructureTypeSwitch("#desktop-sidebar");
          createCauseCheckboxes("causeCheckboxes");
          createCauseCheckboxes("causeCheckboxesDesktop");

          const aggDrought = aggregateData(rawDroughtData, 'monthly');
          const aggSSO = aggregateSSOData(rawSSOFeatures, 'monthly');

          const ctx = document.getElementById("droughtChart").getContext("2d");
          myChart = new Chart(ctx, {
            type: "line",
            data: {
              datasets: [
                { label: "Exceptional", data: aggDrought.map(r => ({ x: r.date, y: r.d4 })), borderColor: "#4F0012", backgroundColor: "rgba(79, 0, 18, 0.7)", fill: "origin", tension: 0.1, pointRadius: 0, order: 1 },
                { label: "Extreme", data: aggDrought.map(r => ({ x: r.date, y: r.d3 })), borderColor: "#9C0924", backgroundColor: "rgba(156, 9, 36, 0.7)", fill: "-1", tension: 0.1, pointRadius: 0, order: 1 },
                { label: "Severe", data: aggDrought.map(r => ({ x: r.date, y: r.d2 })), borderColor: "#EC692D", backgroundColor: "rgba(236, 105, 45, 0.7)", fill: "-1", tension: 0.1, pointRadius: 0, order: 1 },
                { label: "Moderate", data: aggDrought.map(r => ({ x: r.date, y: r.d1 })), borderColor: "#F09D33", backgroundColor: "rgba(240, 157, 51, 0.7)", fill: "-1", tension: 0.1, pointRadius: 0, order: 1 },
                { label: "Abn. Dry", data: aggDrought.map(r => ({ x: r.date, y: r.d0 })), borderColor: "#FDEFA4", backgroundColor: "rgba(253, 239, 164, 0.7)", fill: "-1", tension: 0.1, pointRadius: 0, order: 1 },
                { label: "SSO Count", data: aggSSO.map(r => ({ x: r.date, y: r.count })), borderColor: "#00FF00", backgroundColor: "rgba(0, 255, 0, 0.7)", fill: false, tension: 0, pointRadius: 3, yAxisID: "y2", order: 0 },
                {
                  label: "Special Weather Events",
                  data: specialWeatherEvents.map(event => ({ x: event.date, y: 100, event: event.event, date: event.date.toISOString().split('T')[0] })),
                  type: "scatter",
                  yAxisID: "y",
                  pointRadius: 0,
                  pointHoverRadius: 50,
                  showLine: false,
                  order: -1,
                  tooltip: { callbacks: { label: ctx => `${ctx.raw.date} | ${ctx.raw.event}` } }
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: { mode: "index", intersect: false },
              scales: {
                x: { type: "time", time: { unit: "month", tooltipFormat: "yyyy-MM-dd" }, ticks: { color: "#00d4ff" }, grid: { color: "rgba(0, 212, 255, 0.2)" } },
                y: { stacked: true, min: 0, suggestedMax: 110, ticks: { color: "#00d4ff" }, grid: { color: "rgba(0, 212, 255, 0.2)" } },
                y2: { type: "linear", position: "right", ticks: { color: "#00ff00" }, grid: { drawOnChartArea: false } }
              },
              plugins: {
                legend: { labels: { color: "#00d4ff", font: { family: 'Orbitron' } }, position: "top" },
                title: { display: true, text: "Drought & SSO (Monthly)", color: "#00d4ff", font: { size: 16, family: 'Orbitron' } },
                zoom: { zoom: { wheel: { enabled: true }, drag: { enabled: true }, mode: "x" }, pan: { enabled: true, mode: "x" } },
                annotation: {
                  annotations: [
                    ...specialWeatherEvents.map((e, i) => ({
                      type: 'label', xValue: e.date, yValue: 100, content: e.emoji, color: '#ffffff', font: { size: 20 }, position: 'center', xAdjust: 0, yAdjust: -5, backgroundColor: 'rgba(0, 0, 0, 0)', borderWidth: 0
                    })),
                    {
                      type: 'line',
                      id: 'cursorLine',
                      mode: 'vertical',
                      scaleID: 'x',
                      value: aggSSO[aggSSO.length - 1].date,
                      borderColor: '#00d4ff',
                      borderWidth: 2,
                      label: {
                        enabled: true,
                        content: 'Latest',
                        position: 'top',
                        backgroundColor: 'rgba(0, 212, 255, 0.8)',
                        font: { size: 12, family: 'Orbitron' }
                      }
                    }
                  ]
                },
                tooltip: {
                  mode: "index",
                  intersect: false,
                  backgroundColor: 'rgba(10, 10, 30, 0.9)',
                  titleFont: { family: 'Orbitron' },
                  bodyFont: { family: 'Orbitron' },
                  callbacks: { label: ctx => ctx.dataset.label === "Special Weather Events" ? `${ctx.raw.date} | ${ctx.raw.event}` : `${ctx.dataset.label}: ${ctx.raw.y}` }
                }
              },
              onClick: (event, elements, chart) => {
                const xValue = chart.scales.x.getValueForPixel(event.x);
                if (xValue) {
                  selectedDate = new Date(xValue);
                  const aggSSO = aggregateSSOData(rawSSOFeatures, currentPeriod);
                  selectedDate = aggSSO.reduce((prev, curr) => 
                    Math.abs(curr.date - selectedDate) < Math.abs(prev.date - selectedDate) ? curr : prev
                  ).date;
                  updateChartWithCurrentPeriod();
                  updateMap();
                }
              }
            }
          });

          return initializeMap();
        })
        .then(() => {
          console.log("Initialization complete");
          hideLoading(); // Hide loading overlay when everything is ready
          document.getElementById("toggleMapBtn").addEventListener("click", toggleMapVisibility);
          document.getElementById("weeklyBtn").addEventListener("click", () => { currentPeriod = 'weekly'; updateChartWithCurrentPeriod(); updateMap(); });
          document.getElementById("monthlyBtn").addEventListener("click", () => { currentPeriod = 'monthly'; updateChartWithCurrentPeriod(); updateMap(); });
          document.getElementById("yearlyBtn").addEventListener("click", () => { currentPeriod = 'yearly'; updateChartWithCurrentPeriod(); updateMap(); });
          document.getElementById("resetZoomBtn").addEventListener("click", () => {
            if (myChart) {
              myChart.resetZoom();
              selectedDate = null;
              updateChartWithCurrentPeriod();
            }
            if (mapView) mapView.goTo({ center: [-95.3632715, 29.7632836], zoom: 10 });
            updateMap();
          });
        })
        .catch(error => {
          console.error("Error initializing:", error);
          hideLoading(); // Hide loading even on error to allow user interaction
          alert("Failed to load data. Please try refreshing the page.");
        });
    });

    window.addEventListener('resize', () => {
      toggleSidebar();
      const chartContainer = document.querySelector(".chart-container");
      const mapContainer = document.querySelector(".map-container");
      const contentWrapper = document.querySelector(".content-wrapper");

      if (window.innerWidth <= 768) {
        chartContainer.style.height = mapVisible ? "50vh" : "calc(100vh - 9rem)";
        contentWrapper.style.flexDirection = "column";
        mapContainer.style.height = mapVisible ? "50vh" : "0";
      } else {
        contentWrapper.style.flexDirection = mapVisible ? "row" : "column";
        chartContainer.style.height = mapVisible ? "100%" : "calc(100% - 1rem)";
        mapContainer.style.height = mapVisible ? "100%" : "0";
      }
      if (myChart) myChart.resize();
      // Removed mapView.resize()
    });
  </script>
</body>
</html>
